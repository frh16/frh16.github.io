<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>IX9111 - Unit 1. Introduction |  blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-IX9111/1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  IX9111 - Unit 1. Introduction
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/04/26/IX9111/1/" class="article-date">
  <time datetime="2025-04-26T13:30:01.000Z" itemprop="datePublished">2025-04-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/IX9111/">IX9111</a>
  </div>
 
    </div>
      



  
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong>chunks</strong></p>
<p>Chunks contain extents; extents contain pages Chunks contain extents; extents contain page</p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202504272252887.png" alt="image-20250427225213804"></p>
<p>Informix Dynamic Server disk space is allocated in units called chunks.</p>
<p>To uniquely describe a particular <strong>chunk</strong>, you must specify three things: the chunk <strong>path</strong>, the <strong>offset</strong> (kilobytes) into the device where the chunk begins, and the <strong>size</strong> (kilobytes) of the chunk.</p>
<br>

<p><strong>pages</strong></p>
<p>The <strong>default page size</strong> is either <strong>2</strong> kilobytes or <strong>4</strong> kilobytes, depending on the platform.</p>
<p><code>默认页大小 2KB 或 4KB (kilobytes是KB)</code></p>
<p>The <strong>page size</strong> can be configured for each dbspace from <strong>2K</strong> to <strong>16K</strong> and <strong>must be divisible by the default page size</strong>.</p>
<p><code>页大小可配置为2K - 16K，必须能被默认页面大小整除</code></p>
<p>The <strong>size of a chunk</strong> must be <strong>a multiple of the page size</strong>.</p>
<p><code>chunk的大小必须是页大小的倍数</code></p>
<br>

<p><strong>extents</strong></p>
<p>An <em>extent</em> is a <strong>physically contiguous</strong> group of related pages that are <strong>fully contained in a chunk</strong>.</p>
<p><code>extent是物理上连续的一组相关pages，这些页面完全包含在一个chunk中。</code></p>
<p>Extents are not exclusively associated with tblspaces.The physical log is made from one extent. The 12 reserved pages in the root dbspace could also be called an extent</p>
<p><code>extents不只和tblspaces关联。物理日志由一个extent构成。rootdbs的12个保留页也可以被叫做一个extent</code></p>
<br>

<p><strong>Tblspaces</strong></p>
<p>A tblspace is a set of extents allocated to a specific database object.   </p>
<p><code>tblspace是分配给特定数据库对象的一组extent。</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202504272245936.png" alt="image-20250427224506870"></p>
<p>A <em>tblspace</em> is a logical collection of extents within a dbspace. A tblspace can represent an entire table or index, or a table or index fragment. Each extent can contain a variety of page types. When a tblspace is created, an initial extent is allocated. Its size is 8 pages by default, but can be set using the EXTENT SIZE clause of the CREATE TABLE statement in SQL. As the table grows, new extents must be allocated. The default size of each <em>next</em>  <em>extent</em> is also 8 pages, but can be set using the NEXT SIZE clause.</p>
<p><code>tblspace是dbspace内extent的逻辑集合。tblspace可以表示整个表或索引，也可以表示表或索引的片段。每个extent可以包含多种页类型。创建tblspace时，会分配一个初始extent。其大小默认为8页，但可以使用 SQL 中 CREATE TABLE 语句的 EXTENT SIZE 子句进行设置。随着表的增长，必须分配新的extent，下一个extent的默认大小也是 8 页，但可以使用 NEXT SIZE 子句进行设置。</code></p>
<p>The extent allocation mechanism for tblspaces has a few additional features: </p>
<p><code>tblspace的extent分配机制有一些额外特性</code></p>
<ol>
<li><p>When an extent is allocated adjacent to the extent previously allocated for the same tblspace, the two can be concatenated to form one large extent. </p>
<p><code>当一个extent分配到与先前为同一tblspace分配的extent相邻的位置时，可以将这两个extent连接起来以形成一个大extent。</code></p>
</li>
<li><p>As a tblspace becomes fragmented, the size used for new extent allocations is adjusted upward from its configured value. Specifically, NEXT SIZE is doubled for every 16 extents that are allocated.</p>
<p><code>当一个tblspace变得碎片化时，用于新extent分配的大小会在其配置值的基础上向上调整。具体来说，每分配16个extent，NEXT SIZE就会翻倍。</code></p>
</li>
<li><p>When an extent allocation requires more contiguous space than is available in the dbspace, the server simply allocates the largest amount of contiguous space available.</p>
<p><code>当extent分配所需的连续空间大于 dbspace 中可用的连续空间时，server会直接分配可用的最大连续空间。</code></p>
<p>This mechanism helps to avoid reaching extent allocation limits.</p>
<p><code>此机制有助于避免达到extent分配限制。</code></p>
</li>
</ol>
<br>

<p><strong>Dbspaces, Blobspaces, and Sbspaces</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202504272258506.png" alt="image-20250427225802434"></p>
<p>Dbspaces, blobspaces, and sbspaces are named collections of one or more chunks. These spaces do not define any physical space boundaries, but are <em>logical</em> collections of the <em>physical</em> chunks.</p>
<p><code>前一句不知道怎么翻译，理解成每个space都有名字，由一个或多个chunk组成吧。这些space没有定义任何物理空间边界，而是物理chunk的逻辑集合。</code></p>
<p>A <em>dbspace</em> chunk contains data and index pages in the form of tblspaces. The first dbspace in an Informix Dynamic Server system always contains the first chunk, or <em>root chunk</em>. Therefore, dbspace 1 is always the <em>root dbspace</em>.</p>
<p><code>dbspace chunk以tblspace的形式包含数据页和索引页。IDS的第一个dbspace始终包含第一个chunk，或称为root chunk。因此dbspace 1 始终是 root dbspace</code></p>
<p>A blobspace chunk contains BYTE and TEXT data.</p>
<p><code>blobspace chunk包含BYTE和TEXT数据</code></p>
<p>An sbspace chunk contains smart large object (BLOB and CLOB) data and metadata pages to help manage the data.</p>
<p><code>sbspace chunk包含智能大对象（BLOB 和 CLOB）数据和元数据页，以帮助管理数据。</code></p>
<p><strong>Shared Memory</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505032211153.png" alt="image-20250503221105036"></p>
<p>Shared memory in Informix Dynamic Server is divided into three portions:</p>
<p>IDS中的共享内存分为3个不分：</p>
<p>The <em>resident portion</em> contains the buffer cache and other system information. These shared memory segments can be configured to remain resident in main memory.  </p>
<p><code>“常驻部分”包含缓冲区缓存和其他系统信息。这些共享内存段可以配置为驻留在主内存中。</code></p>
<p>The <em>virtual portion</em> contains information about threads and sessions, data object caching, and temporary data needed for activities such as sorting and parallel data query. This information grows and changes constantly, so the database server must handle the allocation and deallocation of memory.</p>
<p><code>“虚拟部分”包含有关线程和会话、数据对象缓存以及排序和并行数据查询等活动所需的临时数据的信息。这些信息不断增长和变化，因此数据库服务器必须处理内存的分配和释放。</code></p>
<p>Clients connecting to the database server by shared memory leave and collect messages in the <em>message portion</em> of shared memory. This portion is created only if you configure shared memory as a communications method for the server.</p>
<p><code>通过共享内存连接到数据库服务器的客户端会在共享内存的“消息部分”中发送和接收消息。仅当您将共享内存配置为服务器的通信方式时，才会创建此部分。</code></p>
<p><strong>A Local Delete</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505032225865.png" alt="image-20250503222537796"></p>
<p>The above example assumes that the client is using a shared-memory connection.</p>
<p><code>上面的例子假设客户端正在使用共享内存连接。</code></p>
<ol>
<li><p>When you type <strong>dbaccess</strong>, the UNIX shell spawns a client process.</p>
<p><code>当你输入dbaccess，UNIX shell 会生成一个客户端进程。</code></p>
</li>
<li><p>When you connect to a database, the client process connects to Dynamic Server shared memory. The database server (which is chiefly a collection of processes called <strong>oninit</strong>) detects a new connection and creates a session and an <strong>sqlexec</strong> thread for the session. The <strong>sqlexec</strong> thread waits for further instructions from the client.</p>
<p><code>连接到数据库时，客户端进程会连接到动态服务器共享内存。数据库服务（主要是一个称为oninit的进程集合）会检测到一个新连接，并为会话创建一个会话和一个sqlexec线程。sqlexec 线程等待客户端将来的指令。</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505032233662.png" alt="image-20250503223234075"></p>
</li>
<li><p>The client connects to the server with the CONNECT or DATABASE statement. Opening the database involves many read and write operations.</p>
<p><code>客户端通过 CONNECT 或 DATABASE 语句连接服务器。打开数据库涉及许多读写操作。</code></p>
</li>
<li><p>Assume that our <strong>sqlexec</strong> thread decides it must scan page 30 in chunk 4. (By the end of this course, you will understand the method by which a thread arrives at this decision in agonizing detail. For now, be thankful for broad assumptions.) First it finds a free <em>buffer</em>, a page-size swath of memory, in the shared memory buffer pool. It locks this buffer, taking temporary ownership of it. The <strong>sqlexec</strong> thread then places a request for page 30 from chunk 4 into the AIO request queue, and then goes to sleep. Again, speaking in broad generalities, the kernel asynchronous I&#x2F;O system (or the Dynamic Server AIO mechanism) puts the page into the buffer, overwriting whatever was there previously. Then the <strong>sqlexec</strong> thread wakes up and scans the buffer for the desired information. The buffer can now be unlocked, (though not freed), so that other processes who require the same page do not have to read it from disk.</p>
<p><code>假设我们的 sqlexec 线程决定它必须扫描块 4 中的第 30 页。（在本课程结束时，您将理解线程做出此决定的详细过程。现在，请感谢宽泛的假设。）首先，它在共享内存缓冲池中找到一个可用缓冲区，即一个页面大小的内存区域。它锁定此缓冲区，并暂时拥有它。然后，sqlexec 线程将对块 4 中第 30 页的请求放入 AIO 请求队列，然后进入睡眠状态。同样，广义上讲，内核异步 I/O 系统（或 Dynamic Server AIO 机制）将页面放入缓冲区，覆盖先前的内容。然后，sqlexec 线程唤醒并扫描缓冲区以查找所需信息。现在可以解锁缓冲区（但不能释放），以便其他需要同一页面的进程不必从磁盘读取它。</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505032240217.png" alt="image-20250503224006136"></p>
</li>
<li><p>The server process sends an <em>OK</em> message to the client, indicating that the previous operation (database open) was successful. The client then sends the DELETE statement to the server, where it is <em>parsed</em> (the syntax is broken down and interpreted) and optimized (a plan to quickly find the target row(s) is formulated).</p>
<p><code>服务器进程向客户端发送 OK 消息，表示上一个操作（打开数据库）成功。然后，客户端将 DELETE 语句发送到服务器，服务器对其进行解析（语法分解和解释）和优化（制定快速找到目标行的方案）。</code></p>
</li>
<li><p>If transaction logging is turned on for the database about to be modified, by definition, all changes must be logged as part of a transaction. Since the server has received no BEGIN WORK statement to this point, it treats this lone DELETE statement as a singleton transaction, meaning that surrounding the one operation are implicit BEGIN WORK and COMMIT WORK SQL statements. Therefore, before performing the delete operation, the <strong>sqlexec</strong> thread sends a BEGIN WORK log record, a digested form of the BEGIN WORK statement, to the logical log buffer.</p>
<p><code>如果要修改的数据库启用了事务日志记录，那么根据定义，所有更改都必须作为事务的一部分进行记录。由于服务器目前尚未收到任何 BEGIN WORK 语句，因此它会将此单独的 DELETE 语句视为一个单例事务，这意味着围绕该操作的是隐式的 BEGIN WORK 和 COMMIT WORK SQL 语句。因此，在执行删除操作之前，sqlexec 线程会将 BEGIN WORK 日志记录（BEGIN WORK 语句的摘要形式）发送到逻辑日志缓冲区。</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505032244997.png" alt="image-20250503224426924"></p>
<p>The next step is for the server to lock, then modify a particular data page in the <strong>customer</strong>table. There is no reason to read the page from disk if it already exists in shared memory,  so the server first determines whether the page containing the target row is in the buffer pool.</p>
<p><code>下一步是服务器锁定客户表中的特定数据页，然后进行修改。如果该页已存在于共享内存中，则无需从磁盘读取该页，因此服务器首先会确定包含目标行的页是否位于缓冲池中。</code></p>
</li>
<li><p>Let us assume the page had, in fact, been read into a buffer pool by an earlier query, and that this buffer has never been modified. Assuming the buffer is not locked by another thread, the <strong>sqlexec</strong> thread locks it exclusively. Then, prior to changing the data, the server copies the <em>before image</em> of this page to the physical log buffer.</p>
<p><code>假设该页面实际上已被先前的查询读入缓冲池，并且该缓冲区从未被修改过。假设该缓冲区未被其他线程锁定，则 sqlexec 线程会对其进行独占锁定。然后，在更改数据之前，服务器会将该页面的“前映像”复制到物理日志缓冲区。</code></p>
</li>
<li><p>The target row on the page is then deleted.</p>
<p><code>然后删除页面上的目标行。</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505032250593.png" alt="image-20250503225034532"></p>
</li>
<li><p>After deleting the row, the database server writes a DELETE record of the change row. A record of table and row information is copied to the logical log buffer in memory.</p>
<p><code>删除行后，数据库服务会写入更改行的 DELETE 记录。表和行信息的记录被复制到内存中的逻辑日志缓冲区。</code></p>
</li>
<li><p>The singleton transaction is then committed. All associated locks are freed, and a binary version of a COMMIT WORK record is written to the logical log buffer. At this point, if the affected database uses <em>unbuffered</em> logging*,* the server writes the contents of the logical log buffer to the current log file on disk before returning a <em>success</em>status to the client process. Assume for the sake of this example that our database uses <em>buffered</em> logging, in which case the server does not flush the log buffer unless it is full.</p>
<p><code>然后提交单事务。所有关联的锁都会被释放，并且 COMMIT WORK 记录的二进制版本会写入逻辑日志缓冲区。此时，如果受影响的数据库使用非缓冲日志记录，则服务器会将逻辑日志缓冲区的内容写入磁盘上的当前日志文件，然后再向客户端进程返回成功状态。为了便于说明，假设我们的数据库使用缓冲日志记录，在这种情况下，除非日志缓冲区已满，否则服务器不会刷新日志缓冲区。</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505032259197.png" alt="image-20250503225947128"></p>
</li>
<li><p>Once the transaction has committed successfully, the server process sends an <em>OK</em>message back to the client. The server then waits on a condition for further instructions. If the client exits at this point, the following events occur:</p>
<p><code>一旦事务成功提交，服务器进程就会向客户端发送一条 OK 消息。然后，服务器等待进一步的指令。如果客户端在此时退出，则会发生以下事件：</code></p>
<p><strong>-</strong> The session threads release any resources, such as locks or buffers. </p>
<p>会话线程会释放所有资源，例如锁或缓冲区。</p>
<p> <strong>-</strong> The session threads and the session memory disappear.</p>
<p>会话线程和会话内存会消失。</p>
<p> <strong>-</strong> The client detaches from shared memory.</p>
<p>客户端脱离共享内存。</p>
</li>
</ol>
<p><strong>Writing Buffer Pages to Disk</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505032304898.png" alt="image-20250503230458815"></p>
<p>The transaction might be over as far as we are concerned, but nothing our server process did has yet been stored permanently. If shared memory were to vanish suddenly, our changes would be lost.</p>
<p><code>就我们而言，事务可能已经结束，但我们的服务器进程所做的一切还没有被永久保存（持久化）。如果共享内存突然消失，我们的更改也会丢失。</code></p>
<ol>
<li><p>Assuming other sessions continue working after our session disconnected, one of them eventually fills the physical log buffer. The PIO virtual processor flushes the physical log buffer (unless kernel asynchronous I&#x2F;O is used, in which case the kaio thread performs the I&#x2F;O). All before images stored in the buffer are written to the physical log on disk, and the buffer can now be overwritten by new before images.</p>
<p><code>假设我们的会话断开后其他会话继续工作，其中一个会话最终会填满物理日志缓冲区。PIO 虚拟处理器会刷新物理日志缓冲区（除非使用内核异步 I/O，在这种情况下，kaio 线程会执行 I/O）。所有存储在缓冲区中的前像都会写入磁盘上的物理日志，现在缓冲区可以被新的前映像覆盖。</code></p>
</li>
<li><p>Likewise, the LIO virtual processor or the kaio facility flushes the logical log buffer. All transaction log records stored in the buffer, having been packaged there in the form of new logical log pages, are written to the logical log currently in use.</p>
<p><code>同样，LIO 虚拟处理器或 kaio 工具会刷新逻辑日志缓冲区。所有存储在缓冲区中的事务日志记录，都会以新的逻辑日志页的形式打包，并写入当前正在使用的逻辑日志中。</code></p>
</li>
</ol>
<p>Note that the order of these two operations is random, and is usually dependent on which buffer fills first. However, a page cleaner ensures that the before image of a page is written to the physical log before its modified image is written to disk from the buffer pool.</p>
<p><code>请注意，这两个操作的顺序是随机的，通常取决于哪个缓冲区先被填满。但是，页面清理器会确保在页面的修改后映像从缓冲池写入磁盘之前，先将页面的修改前映像写入物理日志。  </code></p>
<p><strong>Performing a Checkpoint</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505032316212.png" alt="image-20250503231650138"></p>
<p>Now that the before image of our page has been written to the physical log and all actions we took on the page have been recorded in the logical log, we can recover the transaction if it became necessary. But replaying transactions using logical logs takes time, and we would rather do as little work as possible during a recovery.At this point, if we were to synchronize the data in shared memory with the data in our chunks—flushing all dirty pages, flushing both log buffers, and marking our current position in the logical log—we would produce a <em>known point of consistency</em>. In the event of a failure, we could return to this synchronization point or <em>checkpoint</em>, replay only the actions taken on the database since then, and the time it would take to get the system back online would be minimized.</p>
<p><code>现在，页面的“前映像”已写入物理日志，并且我们在页面上执行的所有操作都已记录在逻辑日志中，我们可以在必要时恢复事务。但是，使用逻辑日志重放事务需要时间，我们希望在恢复期间尽可能少地执行工作。此时，如果我们将共享内存中的数据与块中的数据同步（刷新所有脏页，刷新两个日志缓冲区，并标记我们在逻辑日志中的当前位置），我们将产生一个已知的一致性点。如果发生故障，我们可以返回到此同步点或检查点，仅重放自那时以来在数据库上执行的操作，从而最大限度地缩短系统恢复在线所需的时间。</code></p>
<ol>
<li><p>First, a checkpoint is <em>requested</em>. There are many conditions or events that trigger a checkpoint request. For example:</p>
<p><code>触发检查点请求的条件或事件有很多。例如：</code></p>
<p><strong>-</strong> The checkpoint time-out value has elapsed and pages have been modified</p>
<p><code>检查点超时值已过且页面已被修改</code></p>
<p> <strong>-</strong> The physical log becomes 75% full</p>
<p><code>物理日志已满 75%</code></p>
<p> <strong>-</strong> The administrator forces a checkpoint</p>
<p><code>管理员强制检查点</code></p>
<p>Configuration parameters that could affect when a checkpoint occurs include:</p>
<p><code>可能影响检查点发生时间的配置参数包括：</code></p>
<p> <strong>-</strong> CKPTINTVL – Specifies the interval between the completion of one checkpoint and the request for the next checkpoint.</p>
<p><code>CKPTINTVL – 指定一个检查点完成与下一个检查点请求之间的间隔。</code></p>
<p> <strong>-</strong> AUTO_CKPTS – If enabled, critical resources are monitored and checkpoint frequency is adjusted to reduce transaction blocking.</p>
<p><code>AUTO_CKPTS – 如果启用，则会监视关键资源并调整检查点频率以减少事务阻塞。</code></p>
<p> <strong>-</strong> RTO_SERVER_RESTART – This parameter specifies, in seconds, the recovery time objective for restarting the database server after a server failure. Checkpoint frequency is adjusted to meet the specified objective.</p>
<p><code>RTO_SERVER_RESTART – 此参数指定服务器故障后重新启动数据库服务器的恢复时间目标（以秒为单位）。检查点频率会进行调整以满足指定的目标。</code></p>
</li>
<li><p>To ensure a point of consistency, the database server sets off a global block to suspend all transactions. Once all servers have reached a point where they can safely suspend their work, checkpoint information is recorded (as if it has already occurred) in the physical log reserve page, but <em>not</em> to the checkpoint reserved page. The global block is then released so that server activity can continue.</p>
<p><code>为了确保一致性点，数据库服务器会触发全局阻塞来暂停所有事务。一旦所有服务器都达到可以安全暂停工作的程度，检查点信息就会被记录在物理日志保留页中（如同已经发生过一样），但不会记录在检查点保留页中。然后全局阻塞会被释放，以便服务器活动可以继续进行。</code></p>
</li>
<li><p>Next, the server flushes the physical log buffer contents to the physical log on disk.</p>
<p><code>接下来，服务器会将物理日志缓冲区中的内容刷新到磁盘上的物理日志中。</code></p>
</li>
</ol>
<p><strong>Non-blocking checkpoints</strong></p>
<p>In version 11.10 of Informix Dynamic Server, new algorithms make it possible to avoid transaction blocking during most types of checkpoints. Because checkpoint information is saved at the beginning of the checkpoint process, it is no longer necessary to block transactions while pages are flushed to disk. If the server is interrupted during a checkpoint, then fast recovery can restore from the previous checkpoint. Blocking checkpoints are still required to perform a system backup, and when other system events occur, such as the adding of a dbspace.</p>
<p><code>在 Informix Dynamic Server 11.10 版本中，新算法可以避免大多数类型的检查点期间的事务阻塞。由于检查点信息在检查点过程开始时保存，因此在将页面刷新到磁盘时不再需要阻塞事务。如果服务器在检查点期间中断，则快速恢复可以从上一个检查点恢复。执行系统备份以及发生其他系统事件（例如添加数据库空间）时仍然需要阻塞检查点。</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505032338289.png" alt="image-20250503233813202"></p>
<ol start="4">
<li>All dirty pages in the shared-memory buffer pool are written to disk by page cleaner threads. Physical and logical log buffers are flushed to disk.</li>
</ol>
<p>   <code>共享内存缓冲池中的所有脏页都由页面清理线程写入磁盘。物理和逻辑日志缓冲区均被刷新到磁盘。</code></p>
<ol start="5">
<li><p>A special record called a <em>checkpoint record</em> is written to the logical log buffer. The physical and logical consistency point on disk is updated to the CKPT reserved page.</p>
<p><code>一个称为检查点记录的特殊记录被写入逻辑日志缓冲区。磁盘上的物理和逻辑一致性点被更新到 CKPT 保留页。</code></p>
</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505032341006.png" alt="image-20250503234102938"></p>
<p><strong>Flushing the Physical Log</strong></p>
<ol start="6">
<li><p>The last step in the checkpoint process is to <em>logically empty</em> the physical log. Logically emptying the log means setting its <em>begin address</em> equal to its current address, an operation that is much less expensive than filling the log with zeros or changing the log in any physical way.</p>
<p><code>检查点过程的最后一步是逻辑上清空物理日志。逻辑上清空日志意味着将其起始地址设置为其当前地址，这个操作比用零填充日志或以任何物理方式更改日志的开销要小得多。</code></p>
</li>
</ol>
<p><strong>Fast Recovery</strong></p>
<p> Always occurs during database server startup</p>
<p><code>总是在数据库服务器启动时发生</code></p>
<p> Brings the database to a consistent state</p>
<p><code>使数据库达到一致状态</code></p>
<p> Consists of two phases</p>
<p><code>包含两个阶段</code></p>
<p>– Physical recovery</p>
<p>物理恢复</p>
<p>– Logical recovery</p>
<p>逻辑恢复</p>
<p>When a database server is brought from Online to Offline mode, the server threads perform a checkpoint to make sure that all data in shared memory gets written to disk. However, events could occur that cause the server to be shut down before it has a chance to complete a checkpoint.</p>
<p><code>当数据库服务器从在线模式切换到离线模式时，服务器线程会执行检查点操作，以确保共享内存中的所有数据都已写入磁盘。然而，某些事件可能会导致服务在完成检查点操作之前关闭。</code></p>
<p><em>Fast recovery</em> is the process that Informix Dynamic Server goes through every time a database server is started. If the database server was terminated abnormally, the fast recovery process uses the physical and logical logs to restore the database server to a state of consistency. There are two phases to the fast recovery process: physical recovery and logical recovery.</p>
<p><code>快速恢复是 IDS 每次启动数据库服务时都会经历的过程。如果数据库服务器异常终止，快速恢复过程将使用物理日志和逻辑日志将数据库服务器恢复到一致性状态。快速恢复过程分为两个阶段：物理恢复和逻辑恢复。</code></p>
<p><strong>Fast Physical Recovery</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505051114478.png" alt="image-20250505111447340"></p>
<p>During the first stage of fast recovery, called <em>physical recovery</em>, all the before images in the physical log are copied to their proper addresses on disk. We overwrite those pages with their before images for a good reason. During normal operation, page cleaner threads are constantly writing dirty pages out from shared memory to the AIO queue (which gets flushed to disk by the AIO VP or by the <strong>kaio</strong> thread). If we are to reproduce the conditions that existed immediately after the last checkpoint, we must ensure that any pages modified and flushed since that checkpoint are replaced with their original images.</p>
<p><code>在快速恢复的第一阶段（称为物理恢复）中，物理日志中的所有前映像都会被复制到磁盘上的正确地址。我们用前映像覆盖这些页面是有原因的。在正常运行期间，页面清理线程会不断将脏页从共享内存写入 AIO 队列（该队列由 AIO VP 或 kaio 线程刷新到磁盘）。如果我们要重现上一个检查点之后的情况，必须确保自该检查点以来修改和刷新的所有页面都被替换为其原始映像。</code></p>
<p>Once this reshelving is done, the physical log is logically emptied (the physical log begin pointer is set to the current pointer).</p>
<p><code>一旦完成重新搁置，物理日志在逻辑上就被清空（物理日志开始指针设置为当前指针）。</code></p>
<p><strong>Fast Logical Recovery</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505051119920.png" alt="image-20250505111924827"></p>
<p>The second stage of fast recovery, <em>logical recovery</em>, remodifies the pages restored by physical recovery. Beginning at the last checkpoint record in the logical logs, the <strong>oninit</strong> process rolls forward from there, bringing the system to exactly the state it was in at the time of the crash. The loose ends are tied up after the last log record is applied; <strong>oninit</strong> rolls back any uncommitted transactions, records the rollback by adding CLRs (compensation log records) in the log, deletes temporary tables, performs index builds deferred during the rollforward as an optimization, and brings the system into Quiescent mode.</p>
<p><code>快速恢复的第二阶段是逻辑恢复，它会重新修改物理恢复所恢复的页面。oninit 进程从逻辑日志中最后一个检查点记录开始前滚，使系统恢复到崩溃时的状态。应用最后一个日志记录后，所有未完成的操作都已完成；oninit 会回滚所有未提交的事务，通过在日志中添加 CLR（补偿日志记录）来记录回滚，删除临时表，执行在前滚过程中作为优化而推迟的索引构建，并将系统置于静默模式。</code></p>
<p><code>紫本200页Quiescent mode翻译成静默模式</code></p>
<p>Then the whole cycle begins again. Attached sessions are free to modify shared memory, and the pages on disk become more and more out of date in relation to the buffer pool. If our database server came down unexpectedly at this point, all modified buffers would vanish. We would have to get those pages back somehow. Fast recovery manages to do just that.</p>
<p><code>然后整个循环再次开始。连接的会话可以自由地修改共享内存，磁盘上的页面相对于缓冲池来说会变得越来越过时。如果我们的数据库服务器此时意外宕机，所有修改过的缓冲区都会消失。我们必须以某种方式恢复这些页面。快速恢复正是这样做的。</code></p>
<p>After completion of the checkpoint, all pages in the buffer cache are in sync with the pages on disk.</p>
<p><code>检查点完成后，缓冲区缓存中的所有页面都与磁盘上的页面同步。</code></p>
<p><strong>Fast Recovery and Checkpoint Messages</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505051132861.png" alt="image-20250505113201794"></p>
<p>Above is an example of messages written to the message log during fast recovery. The message log shows the page at which physical recovery began (in the form chunk_number*:<em>page_offset</em>) and how many before-image pages were examined and restored. It also shows the number of transactions that were committed or rolled back during logical recovery. Finally, the message log shows checkpoint information, including where the checkpoint record was written in the logical logs.</p>
<p><code>以上是快速恢复期间写入消息日志的消息示例。消息日志显示了物理恢复开始的页面（格式为“chunk_number:page_offset”）以及检查和恢复了多少个前映像页面。它还显示了逻辑恢复期间提交或回滚的事务数量。最后，消息日志显示了检查点信息，包括检查点记录在逻辑日志中的写入位置。</code></p>
<p><code>紫本202页基本是快速恢复这块的翻译，而且有例子</code></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://frh16.github.io/2025/04/26/IX9111/1/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2024/04/07/SQLsmith/SQLsmith/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">SQLsmith</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2025
        <i class="ri-heart-fill heart_icon"></i> fengrh
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>