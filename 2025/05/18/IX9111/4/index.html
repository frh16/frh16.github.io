<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>IX9111 - Unit 4. Tblspaces |  blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-IX9111/4"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  IX9111 - Unit 4. Tblspaces
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/05/18/IX9111/4/" class="article-date">
  <time datetime="2025-05-18T08:31:08.000Z" itemprop="datePublished">2025-05-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/IX9111/">IX9111</a>
  </div>
 
    </div>
      



  
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong>The Physical Elements in a Tblspace</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505181632526.png" alt="image-20250518163231397"></p>
<p><strong>Notes:</strong></p>
<p>For the Informix Dynamic Server user who never has a reason to manage a database table below the SQL level, it might be useful to picture a table as simply as a series of data rows. But an IDS administrator must understand tables at the RSAM (Relational Sequential Access Method) level.</p>
<p><code>对于那些从不需要在 SQL 层面之下管理数据库表的 IDS 用户而言，将表简单地看作是一系列数据行可能就足够了。但是，IDS 管理员必须在 RSAM（关系型顺序访问方法）级别上理解表。</code></p>
<p>An Informix Dynamic Server database table is actually a logical combination of several physical elements:</p>
<p><code>IDS 数据库表实际上是多个物理元素的逻辑组合：</code></p>
<ol>
<li><p>SQL level: any system catalog data related to the table (none, in the case of temp tables)</p>
<p><code>与该表相关的任何系统 catalog 数据（对于临时表而言，则没有）。</code></p>
</li>
<li><p>RSAM level: one or more partition pages</p>
<p><code>一个或多个 partition page</code></p>
</li>
<li><p>RSAM level: a number of extents</p>
<p><code>若干 extent</code></p>
</li>
</ol>
<p>A <em>tblspace</em> (or <em>partition</em>) is the logical collection of RSAM-level elements located in a single dbspace. A table can consist of one or more tblspaces, depending on if the table is fragmented.</p>
<p><code>一个 tblspace（或 partition）是位于单个 dbspace 中的 RSAM 级元素的逻辑集合。一个表可以由一个或多个 tblspace 组成，具体取决于表是否分片。</code></p>
<p><strong>How do these elements work together?</strong></p>
<p>An <strong>sqlexec</strong> thread intent on accessing tblspace data must first read the system catalog information related to the table. For each table in a database, there is a corresponding row in <strong>systables</strong>. The row contains information such as the name of the table, various statistics, and a partition number (partnum). </p>
<p><code>一个打算访问 tblspace 数据的 sqlexec 线程，首先必须读取与该表相关的系统目录（system catalog）信息。对于数据库中的每个表，systables 中都有一条对应的记录。该记录包含表名、各种统计信息以及一个分区号（partnum）等信息。</code></p>
<p>The partnum describes the location of that table’s partition page. Among other information on that page are the physical locations of each extent in the table. From those addresses, the thread can easily find the tblspace extents.</p>
<p><code>partnum 描述了该表 partition page 的位置。在该页所包含的其他信息中，还记录了表中每个 extent 的物理位置。通过这些地址，线程就可以轻松地找到 tblspace 的各个 extent。</code></p>
<p><strong>The Database Tblspace</strong></p>
<ul>
<li><p>There is only one database tblspace in the system. It contains information about all databases</p>
<p><code>系统中只有一个 database tblspace。它包含所有 database 的信息</code></p>
</li>
<li><p>The database tblspace partnum is always <strong>0x0100002</strong></p>
<p><code>database tblspace partnum 始终为 0x100002</code></p>
</li>
<li><p>It resides in the root dbspace</p>
<p><code>它位于 root dbspace</code></p>
</li>
<li><p>It can be viewed as a <strong>sysmaster</strong> table called <strong>sysdatabases</strong></p>
<p><code>可将其视为一个 sysmaster 的表，叫做 sysdatabases</code></p>
</li>
</ul>
<p><strong>Notes:</strong></p>
<p>In the root dbspace, partition number 0x0100002 is a special tblspace that is used for tracking all the databases created in a database server. This is known as the <em>database</em> <em>tblspace</em>. It can be thought of as a special, internal database table that can grow just like any other table can. A <strong>sysmaster</strong> table called <strong>sysdatabases</strong> allows users to view the contents of this table, but the table cannot be modified.</p>
<p><code>在 root dbspace 中，partnum 0x0100002 是一个特殊的 tblspace，用于跟踪 server 中创建的所有数据库。这就是 database tblspace。可以将其视为一个特殊的内部数据库表，它可以像其他表一样增长。sysdatabases 表允许用户查看该表的内容，但不能修改该表。</code></p>
<p>The database tblspace is initially four pages in size, but additional extents can be allocated (as with any tblspace) as the need arises.</p>
<p><code>数据库表空间（tablespace）初始大小为四页，但随着需求增长，可（如同任意 tblspace 一样）动态分配额外的 extents。</code></p>
<blockquote>
<p>arise 英[əˈraɪz] 美[əˈraɪz]<br>vi.发生;出现;(由…)引起;(因…)产生;发展;起床;（随着人走近而）逐渐显现;群起反对;</p>
</blockquote>
<p>The database tblspace contains all the information needed to identify any database created in the database server. Each row tracks the name of one database, its owner, the date and time of creation, flags related to its logging mode, and the partition number of <strong>systables</strong>. Once the server has found <strong>systables</strong>, all other tables in the database can be located.</p>
<p><code>数据库 tblspace 包含识别 server 中创建的任何数据库所需的所有信息。每一行都跟踪一个数据库的名称、所有者、创建日期和时间、与日志模式相关的标志以及 systables 的 partition number。一旦 server 找到 systables，就能找到数据库中的所有其他表。</code></p>
<p>The schema of the database tblspace includes a unique index on the database name.</p>
<p><code>database tblspace 的模式（schema）中包含一个基于数据库名称的唯一索引。</code></p>
<blockquote>
<p>gemini 2.5 pro</p>
<ul>
<li><strong>“模式 (schema)”</strong> 在这里指的就是这个<strong>特殊的系统级表空间（或其内部的系统表）的结构</strong>。这个结构定义了它有哪些列（比如数据库名称、所有者、创建日期等）。</li>
<li>句子强调了这个结构的一部分：<strong>“包含一个基于数据库名称的唯一索引”</strong>。这意味着在这个系统表空间（或其内部的系统表）的“数据库名称”这一列上，建立了一个唯一索引，以确保每个数据库的名称都是独一无二的。</li>
</ul>
</blockquote>
<p><strong>Tblspace Extent Allocation</strong></p>
<p>Speaking generally, when a tblspace requires more space, another extent of size NEXT SIZE is allocated. There are, however, three variations on this basic theme:</p>
<p><code>一般而言，当表空间（tblspace）需要更多空间时，会分配一个大小为 NEXT SIZE 的 extent。不过，这一基本机制存在三种变体情况：</code></p>
<p>– Extent size doubling</p>
<p><code>extent size 翻倍</code></p>
<p>– Extent size compliance – Not enough contiguous space for NEXT SIZE? The database server allocates what it can (but not less than 4 pages).</p>
<p><code>extent 大小合规性检查 —— 若没有足够连续空间来分配 NEXT SIZE (所指定的 extent)？ server会分配其所能分配的空间量（但不少于 4 页）。</code></p>
<p>– Extent concatenation</p>
<p><code>extent 连接</code></p>
<p><strong>Notes:</strong></p>
<p>After the first extent allocated to a tblspace fills, the database server attempts to allocate another extent. The amount of space it allocates is normally equal to the size configured for subsequent extents (NEXT SIZE). However, the allocation mechanism is affected by these factors:</p>
<p><code>在分配给 tblspace 的第一个 extent 填满后，server 会尝试分配另一个 extent。分配的空间大小通常等于为后续 extent 配置的大小（NEXT SIZE）。但是，分配机制会受到这些因素的影响：</code></p>
<p><strong>•</strong> The number of existing extents</p>
<p><code>现有 extent 的数量</code></p>
<p><strong>•</strong> The availability of contiguous space</p>
<p><code>连续空间的可用性</code></p>
<p><strong>•</strong> The location of existing TBLspace extents</p>
<p><code>现有表空间（TBLspace）中extents的位置</code></p>
<p><strong>Extent size doubling</strong></p>
<p>When the number of extents within a tblspace becomes large, Informix Dynamic Server attempts to compensate by doubling the value on the partition page. It doubles the next extent size after every 16 extents.</p>
<p><code>当表空间（tblspace）内的 extents 数量变得庞大时，IDS 会尝试通过在分区页（partition page）上将相关值加倍来进行补偿。具体来说，在每分配完 16 个 extent 之后，它会将下一个 extent 的大小加倍。。</code></p>
<blockquote>
<p>compensate 补偿 英[ˈkɒmpenseɪt] 美[ˈkɑːmpenseɪt]</p>
</blockquote>
<p><strong>Not enough space for full extent</strong></p>
<p>If the database server is unable to find the space requested for the extent in the first chunk of the dbspace, it searches the next chunk, and so on. If the server is unable to come up with enough space after searching the chunk free lists for all chunks in the dbspace, it settles for the largest available amount of contiguous space. If this is less than 4 pages, however, the allocation fails with an error indicating there is no free disk space available.</p>
<p><code>如果 server 在数据库空间（dbspace）的第一个 chunk 中无法找到为该 extent 请求的所需空间，它会继续搜索下一个 chunk，依此类推。如果服务器在遍历数据库空间中所有chunk的 chunk free lists 后，仍无法找到足够大的空间，那么它会选择当前可用的最大连续空间进行分配。然而，如果这个最大连续空间的大小小于 4 页，那么分配操作将失败，并返回一个错误，指示没有可用的空闲磁盘空间。</code></p>
<blockquote>
<p>settle<br>英[ˈsetl]<br>美[ˈsetl]<br>v.解决(分歧、纠纷等);定居;（使）沉降，下陷，变得密实;(最终)决定，确定，安排好;结束(争论、争端等);付清（欠款）;（使）平静下来，安静下来，定下心来;殖民;降落;把…放好;使处于舒适的位置;<br>n.高背长椅(老式木家具，有扶手，座下多带柜);</p>
</blockquote>
<p><strong>Existing extent locations</strong></p>
<p>When the database server allocates a new extent that is contiguous to the previously allocated extent, it does not create a new extent. Rather, it extends the size of the last one.</p>
<p><code>当 server 分配一个与先前已分配 extent 相邻的新 extent 时，它并不会创建一个全新的 extent。相反，它会扩展最后一个 extent 的大小。</code></p>
<p><strong>Extent Allocation Question</strong></p>
<p>Suppose a tblspace has 5 extents. What do you think would happen if the next allocated extent were contiguous to the thirdextent? Is this a situation in which extent concatenation can beused?</p>
<p><code>假设某个表空间（tblspace）已包含5个 extent。若接下来分配的extent与第三个 extent 在物理存储上直接相邻（contiguous），您认为会发生什么？这种场景是否属于可应用 extent concatenation 技术的情况？</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505192105922.png" alt="image-20250519210524805"></p>
<p><strong>Notes:</strong></p>
<p>Here is an example showing a tblspace with five extents. The server determines that the next extent can be allocated in the pages that immediately follow the third extent.</p>
<p><code>以下示例展示了一个包含五个 extent 的表空间（tblspace）。server 判定，下一个 extent 可分配在与第三个 extent 物理地址直接相邻的后续存储页中。</code></p>
<p><strong>Index Tblspaces</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505192109867.png" alt="image-20250519210937792"></p>
<p><strong>Notes:</strong></p>
<p>Indexes on tables created by users are stored in tblspaces that are separate from their base tables. An index tblspace can be stored in the same dbspace(s) as a data tblspace, or it can be created in a different dbspace. Indexes can also be fragmented into tblspaces located in different dbspaces.</p>
<p><code>用户创建的表上的索引会存储在与基表相互独立的表空间（tblspace）中。索引表空间（index tblspace）可以与数据表空间（data tblspace）共享同一dbspace，也可以单独创建于其他dbspace。此外，索引还支持跨dbspace分片，即索引的不同部分可分布于多个tblspace（这些表空间可位于不同dbspace内）。</code></p>
<p>Since indexes are stored in their own tblspaces, they also can be identified by a partition number. To find a partition number for an index, you can either run <strong>oncheck -pT</strong> on the table on which the index was created, or you can query the <strong>sysfragments</strong> database, as shown here:</p>
<p><code>由于索引存储在独立的表空间（tblspace）中，因此它们也可通过**分区号（partition number）**进行标识。若要查询某个索引的分区号，您可通过以下两种方式实现：对索引所基于的表运行 oncheck -pT 命令 或 查询数据库的系统目录表 sysfragments（具体方法见下文示例）。</code></p>
<p>​	SELECT HEX(partn) FROM sysfragments WHERE indexname &#x3D; “index_name”;</p>
<p>Index extent sizes are not configurable; the size calculated for the index first and next extent sizes are based on the proportion of the key size in relation to the entire table. Index tblspaces use the same rules for adding extents as data tblspaces.</p>
<p><code>索引的 extent 大小不可配置；系统为索引计算的首个 extent 和 next extent）的大小，是基于索引键（key）大小与整表数据规模的比例关系动态确定的。索引表空间（index tblspace）在分配新 extent 时，遵循与数据表空间（data tblspace）完全相同的规则。</code></p>
<blockquote>
<p>proportion 比例 英[prəˈpɔːʃn] 美[prəˈpɔːrʃn]</p>
</blockquote>
<p>Indexes created on system catalog tables are stored in the same tblspace as their base tables. Extents allocated to system catalog tables contain both data and index pages.</p>
<p><code>在系统目录表（system catalog tables）上创建的索引会存储在与基表相同的表空间（tblspace）中。分配给系统目录表的 extents 会同时包含数据页（data pages）和索引页（index pages），即数据与索引共享同一存储单元。</code></p>
<p><strong>Bitmap Pages</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505192223826.png" alt="image-20250519222314760"></p>
<p><strong>Notes:</strong></p>
<p>An Informix Dynamic Server thread searching for a place to insert data within a tblspace uses that table’s <em>bitmap</em> pages to quickly identify a page with sufficient space. Along with inserts, actions that require bitmap searches include:</p>
<p><code>IDS 一个线程在表空间（tblspace）内搜索可插入数据的位置时，会利用该表的位图页（bitmap pages）快速定位具有足够空间的页。除插入操作外，需要执行位图搜索的其他操作还包括：</code></p>
<p><strong>•</strong> Updates whose resulting <em>tuple</em> (the internal term for a row) no longer fits into the existing slot.</p>
<p><code>更新操作导致生成的元组（tuple，即数据库内部对行的术语）无法再存入其原有的 slot。</code></p>
<p><strong>•</strong> Index operations that allocate new&#x2F;free tblspace pages, such as B-tree splits and index creations.</p>
<p><code>索引操作中需要分配新页或释放页的场景包括：B树分裂（B-tree splits）以及索引创建（index creations）等。</code></p>
<p><strong>•</strong> Tblspace usage reports.</p>
<p><code>Tblspace 使用报告。</code></p>
<p><strong>•</strong> Index and data checkers (<strong>oncheck</strong>).</p>
<p><code>索引与数据校验工具（oncheck）</code></p>
<p><strong>Myth buster</strong></p>
<p><code>误区澄清者</code></p>
<p>Every tblspace extent does not begin with a bitmap page. That would be a considerable waste of space, since each bitmap page can describe thousands of pages. So where do second and third bitmap pages appear in a tblspace, if they exist?</p>
<p><code>并不是每个表空间（tblspace）的 extent 都以一个位图页（bitmap page）开始。那样会造成相当大的空间浪费，因为每个位图页可以描述成千上万个页面。那么，如果存在第二个和第三个位图页，它们会出现在表空间的什么位置呢？</code></p>
<p><strong>Displaying Data Tblspace Bitmap Pages</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505192247198.png" alt="image-20250519224746044"></p>
<p><strong>Notes:</strong></p>
<p>You can view the contents of a bitmap page by running <strong>oncheck -pp</strong>. The syntax for this command is:</p>
<p><code>通过运行 oncheck -pp，可以查看位图页面的内容。该命令的语法为</code></p>
<p>​		oncheck -pp <em>partnum</em> <em>logical_page_num</em></p>
<p>In every tblspace, logical page 0 is the first bitmap page. For smaller tables, it is probably the only bitmap page. In the case of larger tables, there could be several others. To display the first bitmap page for a particular tblspace, determine the partition number for the table, then run the command:</p>
<p><code>在每个 tblspace 中，逻辑页 0 是第一个位图页面。对于较小的表，它可能是唯一的位图页面。对于较大的表，可能还有其他几个页。要显示特定 tblspace 的第一个位图页面，请确定表的 partition number，然后运行该命令：</code></p>
<p>​		oncheck -pp <em>partnum</em> 0</p>
<p>As usual, the first two lines displayed by <strong>oncheck</strong> show the page header. Next, <strong>oncheck</strong>displays one or more rows containing 32 values, each bit value representing one page in the table. The row(s) of 32 values are always complete—padded with several 0 values if necessary—whether the table contains 4 pages or exactly 64.</p>
<p><code>与往常一样，</code>oncheck<code> 输出的前两行会显示页头（page header）信息。 随后，</code>oncheck<code> 会输出一行或多行，每行包含 32 个位值（bit value），每个位值代表表中的一个页。 无论表包含 4 个页还是恰好 64 个页，这行（或多行）32 个位值始终是完整的——若不足 32 位，则会用若干个 0 值填充补齐。</code></p>
<p>To the left of each row of bit values is a <em>page offset</em>, akin to the byte offset you have seen in the slot output from <strong>oncheck</strong>. This decimal number indicates which logical page number is represented by the first bit value in the row, as shown here:</p>
<p><code>在每一行位值（bit value）的左侧，有一个页偏移量（page offset），类似于你在 oncheck 的 slot 输出中见过的字节偏移量（byte offset）。 这个十进制数表示该行中第一个位值所对应的逻辑页号（logical page number），具体示例如下：</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505192255582.png" alt="image-20250519225526534"></p>
<p><strong>Displaying Index Tblspace Bitmap Pages</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505202219055.png" alt="image-20250520221930894"></p>
<p><strong>Notes:</strong></p>
<p>Index tblspaces can contain bitmap pages, index pages, and free pages. Since the same bitmap value (8) is used to indicate both index pages and bitmap pages, the bitmap context is important. Page 0 is always a bitmap page, but all other pages with a bitmap value of 8 are index pages. If the table becomes so large that bitmap entries for index nodes fill the bitmap page, then another bitmap page is created.</p>
<p><code>索引表空间（index tablespace）可以包含位图页（bitmap pages）、索引页（index pages）和空闲页（free pages）。由于使用相同的位图值（8）来同时表示索引页和位图页，因此位图上下文（即页面所处的具体情境或类别）就显得尤为重要。具体而言，页面0始终是位图页，而所有其他位图值为8的页面则均为索引页。如果表变得非常大，以至于用于索引节点的位图条目填满了当前的位图页，那么就会创建另一个位图页。</code></p>
<p>To display the bitmap page for an index tblspace, you must first determine the partnum for the index. You can find this by either running <strong>oncheck -pT</strong> on the source table, or by querying the <strong>sysfragments</strong> system catalog.</p>
<p><code>要显示某个索引表空间（index tblspace）的位图页，首先必须确定该索引的分区号（partnum）。你可以通过在源表上运行 oncheck -pT 命令来查找该分区号，或者通过查询系统目录表 sysfragments 来获取。</code></p>
<p>The <strong>oncheck -pT</strong> command includes tblspace information for each index created on the table. An example is shown on the next page.</p>
<p><code>oncheck -pT 命令会包含在表上创建的每个索引的表空间（tblspace）信息。下一页将展示一个示例。</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505202225828.png" alt="image-20250520222526762"></p>
<p><strong>Displaying System Catalog Bitmap Pages</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505202226010.png" alt="image-20250520222622935"></p>
<p><strong>Notes:</strong></p>
<p>Unlike user-defined tables and indexes, each system catalog table and the indexes for the catalog are created in the same tblspace. The example above shows a bitmap page of a <strong>sysindexes</strong> table. Notice that data pages and index pages appear in the same bitmap. Indexes that share the same tblspace as their parent table are said to be <em>attached indexes</em>.</p>
<p><code>与用户自定义的表和索引不同，每个系统目录表及其对应的索引都是在同一个表空间（tblspace）中创建的。上面的示例展示了 sysindexes 表的一个位图页。请注意，数据页和索引页会出现在同一个位图中。那些与其父表共享同一个表空间的索引被称为附属索引（attached indexes）。</code></p>
<p>Indexes created by users are, by default, <em>detached</em> from their parent table. That is, they are created in separate tblspaces, as shown in previous examples. However, you can create indexes that are attached by using the IN TABLE option of the CREATE INDEX command.</p>
<p><code>用户创建的索引在默认情况下是与其父表分离（detached）的，也就是说，它们是在单独的表空间（tblspaces）中创建的，正如之前的示例所示。然而，你可以通过使用 CREATE INDEX 命令的 IN TABLE 选项来创建与父表关联（即附属）的索引。</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505202230431.png" alt="image-20250520223030371"></p>
<p><code>IDS 的第 11 版继续支持 DEFAULT_ATTACH 环境变量。当该变量设置为 1 时，所有创建的索引都会成为附属索引（即与父表关联）。不过，该变量在文档中已被标记为“已弃用”，未来版本可能不再支持。</code></p>
<p><strong>Home Data Pages</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505212138685.png" alt="image-20250521213844555"></p>
<p><strong>Notes:</strong></p>
<p>Remainder pages and blobpages are types of data pages because they contain portions of rows. But the data in these types of pages is second-tier. Without <em>home rows</em> pointing to them, remainder pieces and blobs would be orphaned. The rowids used by an index refer only to home rows, and never to remainder pieces or blobs.</p>
<p><code>剩余页（remainder pages）和大对象页（blobpages）均属于数据页类型，因为它们包含行数据的部分内容。不过，这些页面中的数据属于次级（非核心）数据。若没有“主行（home rows）”指向它们，剩余数据片段和大对象数据便会成为“无主（孤儿）”数据，无处可依。索引所使用的 rowid 仅指向主行，而绝不会指向剩余数据片段或大对象数据。</code></p>
<p>The <em>data</em> pages we have been talking about are known internally as <em>home data pages</em>, in an effort to distinguish between home rows, and the second-tier data to which home rows can refer.</p>
<p><code>我们一直在讨论的这些数据页在内部被称为主数据页（home data pages），这样做的目的是为了区分主行（home rows）以及主行可能引用的那些次级（第二层级）数据。</code></p>
<p>这一节莫名其妙，基本不懂</p>
<p><strong>Rowids</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505212145897.png" alt="image-20250521214559846"></p>
<p><strong>Notes:</strong></p>
<p>A <em>rowid</em> is a 4-byte code, decipherable only when displayed in hexadecimal notation. The format for a rowid is <strong>0xPPPPPPSS</strong> where the <strong>PPPPPP</strong>, the most significant 3 bytes, contain the logical page number of the row, and the <strong>SS</strong>, the least significant byte, contains the slot number that the row occupies on the page.</p>
<p><code>rowid 是一个 4 字节的编码，只有在以十六进制格式显示时才能被解读。行标识符的格式为 0xPPPPPPSS，其中 PPPPPP（高 3 字节）表示该行所在的逻辑页号，而 SS（低 1 字节）则表示该行在页中所占用的 slot number。</code></p>
<p>A home data page consists of a page header, a slot table, and slots containing data rows. To access a specific slot on a specific data page, one must either stumble upon it during a sequential scan, or pass RSAM the correct rowid.</p>
<p><code>home data page 由页头（page header）、slot table 以及包含数据行的 slots 组成。若要访问特定数据页上的某个特定 slot，要么需在顺序扫描过程中偶然发现它，要么需向随机存储访问方法（RSAM，Random Storage Access Method）传递正确的 rowid。</code></p>
<blockquote>
<p>stumble upon 偶然发现 英[ˈstʌmbl əˈpɒn] 美[ˈstʌmbl əˈpɑːn]</p>
</blockquote>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505212153391.png" alt="image-20250521215319325"></p>
<p><code>上一张幻灯片展示了一个 home data page 的示例。该页是来自一个未命名 tblspace 的逻辑页 3。slot table 中的第 2 个条目指向了一个被高亮显示的 slot。因此，这个 home row 的 rowid 为 0x00000302，简化表示即为 0x302。</code></p>
<p>别往上找，找不到对应</p>
<p><strong>The Data Row: Just a Byte Stream</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505212209654.png" alt="image-20250521220956573"></p>
<p><strong>Notes:</strong></p>
<p>As you have had the opportunity to view Informix Dynamic Server data rows at the binary level, you may have noticed that columns are not aligned on any particular address boundaries. To a C programmer whose assumption is that rows in a tblspace are stored as C structures, this might come as a surprise.</p>
<p><code>既然你已有机会从二进制层面查看 IDS 的数据行，那么你可能已经注意到，列数据并没有对齐到任何特定的地址边界。对于那些原本假设 tblspace 中的行是以 C 语言结构体形式存储的 C 语言程序员来说，这可能会让他们感到意外。</code></p>
<p><strong>Structure alignment</strong></p>
<p>On most computer architectures, the needs of the data bus dictate that an instance of the 11-byte C structure defined in the slide above be stored in memory, as shown on the right. The 1-byte element beginning the structure (<strong>a</strong>) is <em>aligned</em> on an integer boundary, meaning that the memory address of that byte is evenly divisible by 4. The next element (<strong>b</strong>), a 4-byte long integer, must also be aligned on an integer boundary. Therefore, <strong>b</strong> cannot be stored immediately following <strong>c</strong>, and 3 bytes of wasted space separate the two elements. Short integers like the next element must be aligned on short-integer boundaries. Luckily, the address directly following the previous element suffices for <strong>c</strong>. However, the next element (<strong>d</strong>) has to be separated from <strong>c</strong> by 2 bytes, in order to be aligned on an integer boundary. Thus, in this particular case, 16 bytes are used in memory to store 11 bytes of real data.</p>
<p><code>在大多数计算机架构中，数据总线的需求决定了上一张幻灯片中定义的 11 字节 C 语言结构体实例在内存中的存储方式，就如同右侧所示的那样。结构体中以 1 字节元素开头的部分（a）是按整数边界对齐的，这意味着该字节的内存地址能够被 4 整除。接下来的元素（b）是一个 4 字节的长整型，它也必须按整数边界对齐。因此，b 不能紧跟在 a 之后存储，这两个元素之间需要浪费 3 字节的内存空间。像下一个元素这样的短整型（short integer）必须按短整型边界对齐。幸运的是，上一个元素之后的内存地址刚好满足 c 的对齐要求。然而，下一个元素（d）为了按整数边界对齐，必须与 c 间隔 2 字节。因此，在这个特定例子中，为了存储 11 字节的实际数据，内存中实际使用了 16 字节的空间。</code></p>
<p><strong>Data row storage</strong></p>
<p>In most cases, a Dynamic Server data row is not written, stored, or read as a C structure, but as a stream of bytes. Once read, the database server parses the bytes into separate columns based primarily on its knowledge of the schema. This binary method of storage not only saves space, but it puts total control of the data layout in the hands of the engine, making the Dynamic Server source code, and the data itself, more portable.</p>
<p><code>在大多数情况下，server 的数据行并非以 C 语言结构体的形式进行写入、存储或读取，而是以字节流（stream of bytes）的形式来处理。server 在读取数据后，会主要依据对模式（schema）的了解，将这些字节解析为独立的列。这种二进制存储方式不仅节省了空间，还将数据布局的完全控制权交给了数据库引擎，从而使得 server 的源代码以及数据本身具有更高的可移植性。</code></p>
<p><strong>VARCHAR Column Storage</strong></p>
<ul>
<li><p>Extra byte at beginning that contains data length</p>
<p><code>在开头有一个额外的字节，用于存储数据长度</code></p>
</li>
<li><p>Maximum size: 255 characters (maximum length value is <strong>0xff</strong>)</p>
<p><code>最大大小：255 个字符（最大长度值为 0xff）</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505222154583.png" alt="image-20250522215405444"></p>
</li>
</ul>
<p><strong>Notes:</strong></p>
<p>VARCHAR storage is easier to understand than it might look. The first rule to remember is that, because the length of the column data is variable, an extra byte is added to the head of the column to store that length. This might explain why the maximum size of a VARCHAR column is 255 characters. The <em>length</em> byte can store a maximum value of 0xFF, or 255. The second rule relates to the minimum size and the padding required when a column contains less than the minimum configured number of characters. Note that the <em>row</em> is padded, not the VARCHAR column.</p>
<p><code>VARCHAR 类型的存储理解起来可能比看起来要简单。需要记住的第一条规则是，由于列数据的长度是可变的，因此在列的开头会额外添加一个字节来存储该长度。这或许可以解释为什么 VARCHAR 列的最大大小是 255 个字符。这个用于存储长度的字节最大可以存储的值是 0xFF，即 255。第二条规则与最小大小以及当列中包含的字符数少于配置的最小字符数时所需的填充有关。需要注意的是，进行填充的是 row（下段解释），而不是 VARCHAR 列本身。</code></p>
<p>For example, pictured above are three rows of data from the same table, which consists of an INTEGER column (4 bytes), followed by a VARCHAR column configured with a maximum size of 20 bytes and a minimum of 5 bytes, followed by a SMALLINT column (2 bytes). In the first row, the VARCHAR column contains only 3 characters, reflected in the value of the length byte. The configured minimum is 5, however, so while the column data is compressed together into only 10 bytes, a total slot length of 12 is stored in the slot table, effectively <em>padding</em> the row by simply including whatever 2 bytes happen to be out beyond the data.</p>
<p><code>例如，上图展示了来自同一张表的三行数据，这张表包含一个 INTEGER 列（占 4 字节），紧接着是一个配置了最大长度为 20 字节、最小长度为 5 字节的 VARCHAR 列，再接着是一个 SMALLINT 列（占 2 字节）。在第一行中，VARCHAR 列仅包含 3 个字符，这一点在长度字节的值中得到了体现。然而，由于配置的最小长度是 5 字节，所以尽管列数据被压缩到了仅 10 字节，但在 slot table 中存储的总 slot 长度却是 12 字节。这实际上是通过简单地包含超出数据部分的任意 2 字节来对行进行“填充”（padding）的。</code></p>
<p>The data in the padding bytes does not matter because as Informix Dynamic Server reads the row, it can easily tell, based on the length byte preceding each VARCHAR column and the known sizes of all other columns, how many bytes to consider.</p>
<p><code>填充字节中的数据并不重要，因为当 IDS 读取这行数据时，它能够很容易地根据每个 VARCHAR 列前面的长度字节以及所有其他列的已知大小，判断出需要考虑多少个字节。</code></p>
<p>Note that no padding is required for row 2 or 3 because, in each case, the number of characters in the VARCHAR column meets or exceeds the configured minimum of 5.</p>
<p><code>需要注意的是，对于第 2 行或第 3 行数据，并不需要进行填充，因为在每一种情况下，VARCHAR 列中的字符数都达到或超过了所配置的最小长度 5 字节。</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505222229057.png" alt="image-20250522222905998"></p>
<p>The bytes added for padding can contain any values. The server knows they do not contain any meaningful information and does not bother to initialize the bytes.</p>
<p><code>为填充而添加的字节可以包含任何值。服务器知道这些字节不包含任何有意义的信息，因此不会费心去初始化这些字节。</code></p>
<p><strong>Forward Pointers for VARCHAR Rows</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505222250645.png" alt="image-20250522225020556"></p>
<p><strong>Notes:</strong></p>
<p>When a row containing a VARCHAR column is updated such that the VARCHAR column grows, as long as the page has room for the row’s expansion, no remainder page or forwarding pointer are needed. However, in the case of a home data page that is almost full, an expanding row is not able to remain intact on the home page.</p>
<p><code>当包含 VARCHAR 列的一行数据被更新，导致该 VARCHAR 列的内容增长时，只要数据页还有足够的空间容纳这行数据的扩展，就不需要使用剩余页（remainder page）或 forwarding pointer。然而，如果该行数据所在的主数据页（home data page）几乎已满，那么扩展后的行数据就无法完整地保留在主数据页上。</code></p>
<p>In this case, the <em>entire row</em> moves to a remainder page. All that is left in the original slot on the home data page is a 4-byte forwarding pointer.</p>
<p><code>在这种情况下，整行数据会移动到一个剩余页（remainder page）上。而在主数据页（home data page）上原来的 slot 中，仅留下一个 4 字节的 forwarding pointer。</code></p>
<p>Once a row has been forwarded to a remainder page like this, accessing the row of data involves 4 pointers.</p>
<p><code>一旦一行数据像这样被转发到剩余页（remainder page）上，访问该行数据就需要涉及 4 个指针。</code></p>
<ol>
<li><p>The rowid addresses the original slot table entry on the home page.</p>
<p><code>该 rowid 指向主数据页（home page）上原始 slot table 中的条目。</code></p>
</li>
<li><p>The slot table entry points to a forwarding pointer that has replaced the data row on the home page.</p>
<p><code>该 slot table 条目指向一个 forwarding pointer，这个 forwarding pointer 已经替换了主数据页（home page）上原来的数据行。</code></p>
</li>
<li><p>The forwarding pointer is yet another rowid, which points to a slot table entry on the relevant remainder page.</p>
<p><code>这个 forwarding pointer 实际上是另一个 rowid，它指向相关剩余页（remainder page）上的一个 slot table 条目。</code></p>
</li>
<li><p>The slot table entry on the remainder page points to the actual data row.</p>
<p><code>remainder page 上的 slot table 条目指向实际的数据行。</code></p>
</li>
</ol>
<p>根据之前讲的，前3个字节代表逻辑页号，最后1个字节代表 slot number</p>
<p>0x603，逻辑页6，第3个slot</p>
<p>0x701，逻辑页7，第1个slot</p>
<p>下面解释 8004 的 8</p>
<p>Note that a slot table entry that points to a slot containing a forwarding pointer is <em>flagged</em>with a special value: 0x8000 (however, the flag value shown for the slot in <strong>oncheck -pp</strong> is 2).</p>
<p><code>需要注意的是，指向包含 forwarding pointer 的 slot 的 slot table 条目会被标记上一个特殊值：0x8000（然而，在 oncheck -pp 命令中显示该槽的标记值时为 2）。</code></p>
<p>Also note that a deleted slot is indicated by a 0 length in its slot table entry.</p>
<p><code>另外还需注意，slot table 条目中若长度为 0，则表示该 slot 已被删除。</code></p>
<p><strong>Forward Pointers for Large Rows</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505232238710.png" alt="image-20250523223814560"></p>
<p><strong>Notes:</strong></p>
<p>For rows larger than a page, it is not practical to replace the entire home row with a forwarding pointer. Instead, the first 4 bytes are devoted to the forwarding pointer, followed by as much of the row as can fit on the home page. As usual, the value of the 4-byte forwarding pointer is a rowid that points to the first remainder piece.</p>
<p><code>对于超过一页大小的行，用 forwarding pointer 完全替换 home row 上的整行数据并不实际。相反，行的前 4 个字节被用作 forwarding pointer，随后紧跟的是能容纳在主页上的尽可能多的行数据。和往常一样，这 4 字节 forwarding pointer 的值是一个 rowid，它指向 first remainder piece。</code></p>
<blockquote>
<p>practical 实际的 英[ˈpræktɪkl] 美[ˈpræktɪkl]</p>
</blockquote>
<p><strong>Big remainder pages</strong></p>
<p>If the first remainder piece is too large to fit on an entire remainder page, a second 4-byte forwarding pointer is written on the remainder page, followed by as much of the remainder piece as possible, and so on until the entire row has been stored. This type of remainder page (one entirely taken up by a remainder piece and a forwarding pointer) is called a <em>b</em>i<em>g</em> <em>remainder page</em>.</p>
<p><code>如果 first remainder piece  太大，无法完整地存放在一个 remainder page 中，那么会在该 remainder page 上写入第二个 4 字节的 forwarding pointer，随后紧跟的是能容纳在该剩余页上的尽可能多的 remainder piece 数据，以此类推，直到整行数据全部存储完毕。这种完全由一个 remainder piece 数据和一个 forwarding pointer 占据的 remainder page 被称为 big remainder page。</code></p>
<p>Note that the slide above does <em>not</em> show a big remainder page.</p>
<p><code>请注意，上面展示的幻灯片并未显示一个 big remainder page。</code></p>
<p>Also note that the slot table entry for this home row is flagged with the value 0x8000 to indicate that the slot size of 0x7e0 includes a forwarding pointer as the first 4 bytes.</p>
<p><code>另外还需注意，该 home row（即存储行初始部分数据的页）对应的 slot table 条目会被标记上值 0x8000，以此表明该 slot size 为 0x7e0，且其前 4 个字节包含一个 forwarding pointer。</code></p>
<p><strong>Home Page With BLOB Descriptor</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505232310878.png" alt="image-20250523231039798"></p>
<p><strong>Notes:</strong></p>
<p>Informix Dynamic Server supports two different kinds of large objects: <em>simple large objects</em>(<em>blobs</em>) and <em>smart large objects</em> (<em>smart LOs</em>, or <em>smart blobs</em>). Only simple large objects can be stored in partition pages.</p>
<p><code>IDS 支持两种不同类型的大对象：简单大对象（simple large objects，简称 blobs） 和 智能大对象（smart large objects，简称 smart LOs 或 smart blobs）。只有简单大对象可以存储在 partition page 中。</code></p>
<p>The data in a blob column is never stored on home data pages with non-blob column data. Blobs are either segregated into different chunks, as when they are configured to reside in a blobspace, or forwarded to special <em>partition blobpages</em> within the tblspace (the default configuration). But because of the complexity of blob management, a lone 4-byte forwarding pointer on the home page describing only the blob’s location does not suffice. Instead, a 56-byte <em>descriptor</em> is stored on the home page in place of the blob data. Even a home row that has a NULL value in its blob column contains an entire 56-byte blob descriptor, albeit a dull one.</p>
<p><code>BLOB（二进制大对象）列中的数据绝不会与非 BLOB 列的数据一起存储在 home data page 上。BLOB 数据要么被分隔到不同的 chunk 中（例如，当配置为位于blobspace 中时），要么被 forward 到表空间（tblspace，此为默认配置）内的特殊 partition blobpages 中。然而，由于 BLOB 管理的复杂性，仅在主页（home page）上放置一个孤零零的 4 字节 forwarding pointer 来描述 BLOB 的位置是不够的。相反，主页上会存储一个 56 字节的描述符（descriptor）来替代 BLOB 数据。即便某个主页行（home row）的 BLOB 列值为 NULL，它仍然会包含一个完整的 56 字节 BLOB 描述符，只不过这个描述符的内容是“无意义”的。</code></p>
<p><strong>Partition blob</strong> </p>
<p>Partition blobpages differ from blobspace blobpages in several important ways. Partition blobpages are more like other Dynamic Server pages; they are the same size (BUFFSIZE), whereas the blobspace blobpage size can be configured to any multiple of BUFFSIZE. Partition blobpages are modified in the shared memory buffer pool; blobspace blobpages are not. Partition blobpages are written to logical logs with their corresponding data row. Blobspace blobpages are not logged.</p>
<p><code>partition blobpages 与 BLOB 空间 BLOB 页（blobspace blobpages）在几个重要方面存在差异。Partition blobpages 更类似于其他 Dynamic Server 页；它们大小相同（均为 BUFFSIZE），而 BLOB 空间 BLOB 页的大小可以配置为 BUFFSIZE 的任意整数倍。Partition blobpages 在共享内存缓冲池中进行修改；而 BLOB 空间 BLOB 页则不会在此处修改。Partition blobpages 会与其对应的数据行一同写入逻辑日志；而 BLOB 空间 BLOB 页则不会被记录到日志中。</code></p>
<p><strong>BLOB Descriptor Structure</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505232331704.png" alt="image-20250523233146617"></p>
<p><strong>Notes:</strong></p>
<p>On the slide above is the layout of the 56-byte blob descriptor. This structure is not only stored on home data pages, but is used throughout the database server for various blob-related reading, writing, and manipulating activities. As a result, there are several elements included in the structure that store fascinating data for fleeting moments, but do not contain anything of interest when the blob descriptor is at rest, as it is on disk.</p>
<p><code>上面幻灯片展示的是 56 字节 BLOB 描述符的布局结构。这种结构不仅存储在主数据页（home data pages）上，还在整个数据库服务器中用于各种与 BLOB 相关的读取、写入和操作活动。因此，这个结构体中包含若干元素——它们在某些瞬间可能存储着极具价值的数据，但当描述符处于静止状态（如存储在磁盘上时），这些元素就不再包含任何有意义的信息。</code></p>
<p>The two-byte <strong>flags</strong> element of the descriptor structure contains any <em>one</em> of the following flag values:</p>
<p><code>描述符结构中的两字节 flags 元素包含以下任意一个标志值：</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505232337332.png" alt="image-20250523233748283"></p>
<p>In an upcoming exercise, you will use the <strong>oncheck -pD</strong> command to view and analyze the blob descriptor.</p>
<p><code>在接下来的练习中，你将使用 oncheck -pD 命令来查看和分析 blob descriptor。</code></p>
<p><strong>Partition Blobpages</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505242215041.png" alt="image-20250524221525914"></p>
<p><strong>Notes:</strong></p>
<p>A partition blob consists of one or more blob <em>pieces</em>. Blob data that is too large to fit on one partition blobpage is split into several blob pieces chained together with forwarding pointers. Like a chain of remainder pieces for a very large row, all but the last blob piece in a chain is given its own blobpage so that the fewest possible number of pages are involved.</p>
<p><code>partition blob 由一个或多个 blob piece 组成。若大对象数据过大，无法容纳于单个partition blobpage 中，则会将其拆分为多个blob piece，并通过forwarding pointers将这些 piece 串联起来。这就好比针对超大行数据所形成的 a chain of remainder pieces，除链中的最后一个 blob piece 外，其余所有 blob piece 都会分配各自独立的 blobpage，以确保涉及的 blobpage 数量尽可能少。</code></p>
<p>Above is a partition blobpage that contains two blob pieces. By definition, each of these blob pieces must be from a different blob.</p>
<p><code>上图展示的是一个包含两个 blob piece 的 partition blobpage。根据定义，这两个 blob piece 必定来自不同的 blob。</code></p>
<p>A blob piece consists of the blob data itself, preceded by 8 bytes of overhead related to forwarding.</p>
<p><code>一个 blob piece 由 blob 数据本身以及其前面与 forwarding 相关的 8 字节开销（overhead）组成。</code></p>
<p><strong>bstamp (2 bytes)</strong></p>
<p>The blobstamp occupies the first two bytes of a blob piece. Blobstamps help Dynamic Server verify the consistency of a chain of blob pieces, which could involve hundreds of pages. Note that the blobstamp does not have to be the same value for all pieces in the chain.</p>
<p><code>大对象时间戳（blobstamp）占据一个大对象片段（blob piece）的前两个字节。大对象时间戳有助于 Dynamic Server 验证由数百个页可能构成的大对象片段链的一致性。需要注意的是，该链中所有片段的大对象时间戳的值并不一定相同。</code></p>
<p>A stamp for a particular blob piece simply has to match what was expected by the previous piece (or the descriptor itself, in the case of the first piece). Otherwise, expect this ISAM error:</p>
<p><code>某个特定大对象片段（blob piece）的时间戳只需与前一个片段（或对于第一个片段而言，是与描述符本身）所预期的时间戳相匹配即可。否则，将会遇到以下 ISAM 错误：</code></p>
<p>​		-164 ISAM error: TEXT or BYTE stamp is incorrect.</p>
<p><strong>Next blobpage (4 bytes)</strong></p>
<p>This element looks and functions exactly like the forwarding pointers you have already studied. It contains the rowid of the next blob piece in the chain, if one exists. The last blob piece in the chain has a <em>next blobpage</em> value of 0xffffffff.</p>
<p><code>这个元素无论是看起来还是功能上都与你之前研究过的 forwarding pointers 完全一致。如果链中存在下一个大对象片段（blob piece），它会包含该片段的 rowid。而链中的最后一个大对象片段，其 next blobpage 的值会被设置为 0xffffffff，以此表示链的结束。</code></p>
<p><strong>nbstamp (2 bytes)</strong></p>
<p>This is the expected blobstamp for the next blob piece in the chain.</p>
<p><code>这是链中下一个大对象片段（blob piece）所预期的大对象时间戳（blobstamp）。</code></p>
<p><strong>oncheck -pT</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505242245718.png" alt="image-20250524224520621"></p>
<p><strong>Notes:</strong></p>
<p>The output from <strong>oncheck -pT</strong> is a super-set of the output from <strong>oncheck -pt</strong>. Information from the partition structure and the extent slot is displayed first, followed by quite a bit of useful information on the complexion of the tblspace, all of which is in decimal.</p>
<p><code>oncheck -pT 命令的输出是 oncheck -pt 命令输出的超集。它会首先显示 partition structure 和 extent slot 的相关信息，随后会提供大量关于表空间（tblspace）状况的有用信息，所有这些信息均以十进制格式呈现。</code></p>
<p>The first portion of this extra output for a sample table is shown in the slide above. It is a general usage report for the tblspace that tallies up the number of free pages, bitmap pages, index pages, home data pages, remainder pages and partition blobpages. (This sample table contains both VARCHARS and partition-resident blobs.) The 4-bit bitmap page is used to determine the relative fullness of the remainder pages and partition blobpages.</p>
<p><code>上述幻灯片中展示了针对一个示例table，这部分额外输出的第一部分内容。它是一份关于表空间（tblspace）的通用使用情况报告，其中汇总了 free pages、bitmap pages、index pages、home data pages、remainder pages 以及 partition blobpages 的数量。（这个示例表中同时包含了 VARCHARS and partition-resident blobs）这里提到的 4-bit bitmap page 用于确定 remainder pages and partition blobpages 的相对填充程度。</code></p>
<p>The total number of unused bytes on each data-related page type is tallied next.</p>
<p><code>接下来会对每种与数据相关的页类型上未使用的字节总数进行汇总。</code></p>
<p>If a table seems to be performing poorly, or using more space than one would expect, this report can be enlightening. For example, if <strong>oncheck -pT</strong> clearly shows that the table is using space inefficiently, a review of the schema might reveal that the row size is just 20 bytes more than the amount of unused space on every full data page, and that a 4 byte reduction in the row size would compact the table by 15%. It has happened.</p>
<p><code>如果某个表看起来性能不佳，或者占用的空间超出了预期，那么这份报告可能会提供有价值的见解。例如，如果 oncheck -pT 报告清晰地显示出该表的空间使用效率低下，那么对表schema的审查可能会揭示出，row size 仅比每个满数据页上未使用的空间多出 20 字节，而如果将行大小减少 4 字节，就可以使表的占用空间减少 15%。这种情况确实发生过。</code></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://frh16.github.io/2025/05/18/IX9111/4/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2025/05/25/IX9111/5/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            IX9111 - Unit 5. Index Architecture
          
        </div>
      </a>
    
    
      <a href="/2025/05/09/IX9111/3/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">IX9111 - Unit 3. Dbspace Layout</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2025
        <i class="ri-heart-fill heart_icon"></i> fengrh
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>