<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>IX9111 - Unit 2. The Dynamic Server Page |  blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-IX9111/2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  IX9111 - Unit 2. The Dynamic Server Page
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/05/05/IX9111/2/" class="article-date">
  <time datetime="2025-05-05T14:00:00.000Z" itemprop="datePublished">2025-05-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/IX9111/">IX9111</a>
  </div>
 
    </div>
      



  
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong>Page: Smallest Unit of I&#x2F;O</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505052201901.png" alt="image-20250505220102809"></p>
<p><em>Pages</em> are the most basic unit of I&#x2F;O in Informix Dynamic Server; a server process does not read or write to a chunk in an increment smaller than a page. As often as possible, however, I&#x2F;O is performed on more than one page at a time.</p>
<p><code>在 IDS 中，页是 I/O 的最基本单位；服务进程在访问一个 chunk 时，读取或写入的最小单位就是一个页面。不过，I/O 通常会同时在多个页面上执行。</code></p>
<p>The default page size for a machine is either 2KB or 4KB depending on the platform. You can configure the page size for each dbspace to be any value from 2KB to 16KB, but the value must be divisible by the default page size.</p>
<p><code>机器的默认页面大小为 2KB 或 4KB，具体取决于平台。你可以将每个dbspace的page size配置为 2KB 至 16KB 之间的任意值，但该值必须能被默认页面大小整除。</code></p>
<p>At a binary level, each allocated page in a system contains a unique stream of data. But the structure and meaning of that data is always based on a handful of templates. This module teaches you how to recognize the structural similarities between Dynamic Server pages, and decipher the important parts of those structures. These skills help you understand Dynamic Server architecture and behavior to a degree you never thought possible.</p>
<p><code>在二进制层面上，系统中分配的每个页面都包含唯一的数据流。但这些数据的结构和含义总是基于一些模板。本模块教你如何识别 Dynamic Server 页面之间的结构相似性，并解读这些结构的重要部分。这些技能将帮助你理解 Dynamic Server 结构和行为，达到你从未想象过的程度。</code>  </p>
<p><strong>Our Imagined View of a Page</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505052211934.png" alt="image-20250505221109866"></p>
<p><code>Linux中的od命令是一个十六进制和其他进制的转换工具，它可以用于显示二进制文件的内容。-x：以十六进制的形式显示文件内容；</code></p>
<p>It is rarely convenient to picture a block of bytes as a continuous stream. Our preference is to reorganize the bytes so they can be viewed as if words are seen on a printed page.</p>
<p><code>将字节块想象成连续的数据流并不方便。我们更倾向于重新组织字节，使它们可以像印刷页面上的文字一样被查看。</code></p>
<p>In the example above, the <strong>od</strong> (octal dump) utility in UNIX and Linux displays a byte stream from a page. In this output, the numbers on the left represent byte offsets in <em>octal</em> and are not part of the data. The rest of the output is the actual stream of bytes from the <strong>rootchunk</strong>file displayed as hexadecimal values (courtesy of the <strong>-x</strong> option). Note that two hexadecimal digits (<strong>7c</strong>, for instance) represent one byte of data. Therefore, with a little counting, you can see that <strong>od</strong> displays 16 bytes of data on each line. The significance of the number 16 is that it equals 0x10 (hexadecimal 10).</p>
<p><code>在上面的示例中，UNIX 和 Linux 中的 od（八进制转储）实用程序显示了一个页面的字节流。在该输出中，左边的数字代表八进制的字节偏移量，并不是数据的一部分。输出的其余部分是以十六进制值显示的 rootchunk 文件的实际字节流（由 -x 选项提供）。请注意，两个十六进制数字（例如 7c）代表一个字节的数据。因此，只要稍微数一数，就可以看到 od 每行显示 16 个字节数据。数字 16 的意义在于它等于 0x10（十六进制 10）。</code></p>
<p>Because most programmers are familiar with this output format, we tend to picture Dynamic Server pages the same way: as a certain number of 16-byte lines. Therefore, this is the standard used in the Informix Dynamic Server course manuals.</p>
<p><code>由于大多数程序员都熟悉这种输出格式，我们往往会以同样的方式来描绘 Dynamic Server 页面：一定数量的 16 字节行。因此，这是 IDS 课程手册中使用的标准。</code>  </p>
<p><strong>Page Layout</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505052222234.png" alt="image-20250505222202164"></p>
<p>The layout of a page is shown in the slide above.</p>
<p><code>页面布局如上图所示。</code></p>
<p><strong>Page header</strong></p>
<p>The page header occupies the first 24 bytes on the page. It contains such information as the location, type, and current capacity of the page.</p>
<p><code>页头占页面的前 24 个字节。它包含页面的位置、类型和当前容量等信息。</code></p>
<p><strong>Timestamp</strong></p>
<p>Each time a page is modified, the timestamp field, located in the last 4 bytes of the page, is updated. The timestamp can be used to compare with other pages to determine which was updated most recently.</p>
<p><code>每次修改页面时，位于页面最后 4 个字节的时间戳字段都会更新。时间戳可用于与其他页面进行比较，以确定哪个页面是最近更新的。</code></p>
<p><strong>Slot table</strong></p>
<p>The slot table enables the database server to quickly find data on a page. It is a series of 4-byte entries that begins at the page-ending timestamp and grows toward the beginning of the page. Each entry in the table describes one <em>slot</em> on the page, which can contain a data row, or some other structure. A slot table entry is comprised of two parts: the location of the slot’s first byte and the length of the slot. A slot table entry functions as a kind of pointer, allowing direct, random access to slots on the page.</p>
<p><code>槽表使数据库服务能够快速查找页面上的数据。它是一系列 4 字节的条目，从页面结束的时间戳开始，向页面的开头延伸。表中的每个条目描述页面上的一个槽，其中可以包含数据行或其他结构。槽表项由两部分组成：槽的第一个字节位置和槽的长度。槽表项作为一种指针，允许直接随机访问页面上的槽。</code></p>
<p>Page types that tend to be searched sequentially do not utilize a slot table, although they can have one. Logical log pages are an example of a page type that has no slot table at all.</p>
<p><code>倾向于按顺序搜索的页面类型不使用slot table，尽管它们可以有slot table。逻辑日志页就是完全没有slot table的页面类型。</code></p>
<p>紫本177页：</p>
<p><code>slots table：为 slots 描述信息，数据页中有多少 slots，则会对应多少个 slots bitmap，每个占用 4 Byte，记录 slots 在页内的偏移地址和长度，当记录被删除时，只是将其中的占用长度设置为 0，在物理上并没有将记录信息清空。</code></p>
<p><strong>Page Header Overview</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505052238924.png" alt="image-20250505223812841"></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505052240740.png" alt="image-20250505224026671"></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505052241776.png" alt="image-20250505224107724"></p>
<p>The <strong>pg_offset</strong> field contains the <em>page offset</em>, which indicates the physical location of the page within the chunk.</p>
<p><code>pg_offset 字段包含页面偏移量，表示页面在chunk中的物理位置。</code></p>
<p>The page offset value is incremented by one for each subsequent page in the chunk. The first page in a chunk has a <strong>pg_offset</strong> value of 0. The maximum <strong>pg_offset</strong> value is based on the maximum size of a chunk, which is around 4 terabytes.</p>
<p><code>页偏移值每增加一页，页面偏移值就递增一次。chunk中的第一个页面的 pg_offset 值为 0。 最大 pg_offset 值基于chunk的最大大小，约为 4 TB。</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505052245545.png" alt="image-20250505224529492"></p>
<p><strong>Chunk number</strong></p>
<p>The <strong>pg_chunk</strong> field contains the number of the chunk where the page is located. Chunk numbering starts at 1. The combination of the <strong>pg_chunk</strong> and <strong>pg_offset</strong> provide all the information needed to identify the <em>page address</em>. The maximum <strong>pg_chunk</strong> value is 32,767.</p>
<p><code>pg_chunk 字段包含页面所在chunk的编号，chunk编号从 1 开始。pg_chunk 和 pg_offset 的组合提供了识别页面地址所需的全部信息。pg_chunk 的最大值为 32,767。</code></p>
<p>紫本176页：</p>
<p>Page Address ： 存 储 页 的 地 址 信 息 ， 占 用 6 Byte ， 由 两 部 分 组 成 ：chunknum+pageoffsize，其中 chunknum 占用 2 Byte，包含了符号位，故支持的最大 chunk 数为 FFFF&#x2F;2&#x3D;32767，也就是说一个 GBase 8t 实例最多可以支持 32767个 chunk。Pageoffzie 占用 4 Byte，故一个 chunk 的最大页数 FFFFFFFF 去掉符号位&#x3D;2 的 31 次方＝2 billion，对于 2k 的 pagesize，最大的空间为 4T&#x3D;22 的 31 次方*2K&#x3D;2 147 483 648*2k。</p>
<p><strong>Page checksum</strong></p>
<p>The <strong>pg_cksum</strong> field stores a checksum value that is used to validate the consistency of a page.</p>
<p><code>pg_cksum 字段存储一个校验和值，用于验证页面的一致性。</code></p>
<p>紫本：CHKSUM：校验位，占用 2 Byte。</p>
<p><strong>Number of Slots</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505062019861.png" alt="image-20250506201908729"></p>
<p>You might expect <strong>pg_nslots</strong> to equal the number of active (undeleted) slots on a page. But in fact, <strong>pg_nslots</strong> indicates the <em>highest</em> number of active slots on the page.</p>
<p><code>你可能会认为 pg_nslots 的值等于页面上活动（未被删除）slot的数量。但实际上，pg_nslots 表示的是页面上曾经出现过的最高活动slot编号。。</code></p>
<p>The <strong>pg_nslots</strong> field is not decremented, even if slots are deleted. Take the case of a data page, for example. If slots 1 through 4 out of a total of five slots are deleted, slot 5 cannot be made slot 1 in the interest of space efficiency because the rowid for that slot would change. Even though only one slot is active on the page at that point, <strong>pg_nslots</strong> must remain 5 to enable a sequential scan (which does not care about rowids) to search far enough into the slot table.</p>
<p><code>字段 pg_nslots即使在删除了slot之后也不会减少。以一个数据页为例，假设在总共五个slot中，slot 1到4被删除，那么slot 5也不能为了节省空间而变成slot 1，因为这样会导致该slot的 rowid发生变化。尽管此时这个数据页上只剩下一个有效插槽，pg_nslots 仍必须保持为5，以便顺序扫描（这种扫描方式不关心 rowid）时可以搜索到足够深的位置，访问插槽表中的所有项。</code></p>
<p><strong>Maximum number of slots</strong></p>
<p>The maximum number of slots for a data page is 255.</p>
<p><code>数据页的最大slot数为 255 。</code></p>
<p><strong>Page Flags (Type)</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505062044751.png" alt="image-20250506204451656"></p>
<p>The <strong>pg_flags</strong> field contains one or more <em>page flags</em>, which are represented by hexadecimal values that are logically <em>OR</em>ed together. The values have the following meanings in Informix Dynamic Server:</p>
<p><code>pg_flags 字段包含一个或多个页面标志，这些标志由十六进制值表示，并通过逻辑 或 运算组合在一起。这些值在 IDS 中的含义如下：</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505062048500.png" alt="image-20250506204838394"></p>
<p><strong>Free Pointer and Free Count</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505062052779.png" alt="image-20250506205217703"></p>
<p>The <strong>pg_frptr</strong> (<em>free pointer</em>) field points to the first free byte <em>after</em> all of the data on a page. If the last slot on a page is occupied, the free pointer points to the position just after that slot.</p>
<p><code>pg_frptr（空闲指针）字段指向页面上所有数据之后的第一个空闲字节。如果页面上的最后一个slot已被占用，那么空闲指针就会指向该slot之后的位置。</code></p>
<p>The <strong>pg_frcnt</strong> (<em>free count</em>) field is a sum of all unused bytes on the page.</p>
<p><code>pg_frcnt（空闲数）字段表示页面上所有未使用字节的总和。</code></p>
<p>紫本上这两个位置写的是Pfree和Nfree，和IX9111不一致</p>
<p><strong>Next Pointer and Previous Pointer</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505062058207.png" alt="image-20250506205843125"></p>
<p>The last two 4-byte elements in the page header structure are not always populated. Their main use is as node pointers on index pages. On an index page, also referred to as an index <em>node</em>, these pointers contain the logical page numbers of the two adjacent nodes. The <em>next pointer</em> (<strong>pg_next</strong>) contains the logical page number of the node to the <em>right</em>(containing higher key values), while the <em>previous pointer</em> (<strong>pg_prev</strong>) contains the logical page number of the node to the <em>left</em> (containing lower key values).</p>
<p><code>页头结构中最后两个 4 字节的元素并不总是被填充。它们的主要用途是在索引页中充当节点指针。在索引页中（也称为索引节点），这些指针包含两个相邻节点的逻辑页号。pg_next 指针包含右侧节点（包含较大键值）的逻辑页号，而 pg_prev 指针则包含左侧节点（包含较小键值）的逻辑页号。</code></p>
<p>The difference between physical and logical page numbers, and the B+ tree concepts of right and left index nodes, are explained in later modules.</p>
<p><code>物理页号与逻辑页号之间的区别，以及 B+ 树中右侧和左侧索引节点的概念，将在后续模块中进行解释。</code></p>
<p>The next and previous-pointer elements were designed into the page-header structure for use in index pages. But instead of wasting eight bytes in the header of all non-index pages, uses have been found for the next and previous pointers in a couple of other page types as well. Their use in logical log pages and tape-header pages, for example, are explained in later modules.</p>
<p><code>next 和 previous 指针元素最初是为了在索引页中使用而被设计进页头结构的。但为了避免在所有非索引页的页头中浪费这8个字节，这两个指针也被用于其他几种页面类型。例如，它们在逻辑日志页和磁带头页中的用途将在后续模块中进行说明。</code></p>
<p>紫本：</p>
<p>Next Page：占用4 Byte，指向下页的地址，对于数据页为0，对于索引页则指向下一个节点。</p>
<p>Previous Page：占用4 Byte，指向上页的地址，对于数据页为0，对于索引页则存储前页地址。</p>
<p><strong>Big Pages</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505062110830.png" alt="image-20250506211014737"></p>
<p>The default page size used for your Informix Dynamic Server instance is either 2K or 4K, depending on the platform (machine and operating system) you are using. For example, a 4K page size is the default for Windows and IBM AIX, and a 2K page size is the default for most other platforms. The root dbspace is always created using the default page size.</p>
<p><code> IDS 实例的默认页面大小是 2K 或 4K，具体取决于所使用的平台（包括机器和操作系统）。例如，Windows 和 IBM AIX 平台的默认页面大小是 4K，而大多数其他平台的默认页面大小是 2K。</code><mark>root dbspace 总是使用默认的页面大小创建。</mark></p>
<p>When you add dbspaces, you can specify a different page size using a multiple of the default page size with a maximum size of 16 kilobytes. Before you create a dbspace that uses a larger page size, you will want to configure a separate buffer pool for that page size. Configure a new buffer pool by setting the BUFFERPOOL configuration parameter. For example:</p>
<p><code>当你添加 dbspace 时，可以使用默认页面大小的倍数来指定不同的页面大小，最大支持 16KB。在创建使用较大页面大小的 dbspace 之前，建议先为该页面大小配置一个单独的缓冲池。你可以通过设置 BUFFERPOOL 配置参数来配置新的缓冲池。例如：</code></p>
<p>BUFFERPOOL <strong>size&#x3D;8k</strong>,buffers&#x3D;2000,lrus&#x3D;8,lru_min_dirty&#x3D;50,lru_max_dirty&#x3D;60</p>
<p>When the new buffer pool has been created, you can then create a dbspace using the larger page size. For example:</p>
<p><code>当新的缓冲池创建完成后，你就可以使用更大的页面大小来创建 dbspace。例如：</code></p>
<p>onspaces -c -d dbsp_bigp <strong>-k 8K</strong> -p &#x2F;opt&#x2F;dbsp3 -o 0 -s 8000</p>
<p><strong>Displaying a Page</strong></p>
<p> Oncheck commands</p>
<p>oncheck -pP chunk_number page_offset</p>
<p>oncheck -pp partition_number logical_page_number</p>
<p> Chunk numbers are indexed from 1</p>
<p><code>chunk号从1开始</code></p>
<p> Both the page offset into a chunk and the logical page number within a table are indexed from 0</p>
<p><code>chunk中的页面偏移量和表中的逻辑页面号都是从 0 开始的</code></p>
<p> To obtain a partition number:</p>
<p>– Query <strong>systables</strong> (or <strong>sysmaster:systabnames</strong>) if the table is not fragmented</p>
<p>– Query <strong>sysfragments</strong> if the table is fragmented</p>
<p>– Run <strong>oncheck -pt</strong> to find all partnums of all fragments</p>
<p> The <strong>oncheck</strong> utility recognizes both decimal (100) and hexadecimal (0x64) format for its arguments</p>
<p><code>oncheck 工具支持十进制（100）和十六进制（0x64）格式的参数。</code></p>
<p>When logged on as either <em>root</em> or <em>informix</em>, you can display most pages within an Informix Dynamic Server chunk using the <strong>oncheck</strong> utility. Based on the type of page it finds, <strong>oncheck</strong> even attempts to print the data on the page in an organized format.</p>
<p><code>当以 root 用户或 informix 用户登录时，可以使用 oncheck 工具查看 IDS chunk中的大多数页面。根据所找到的页面类型，oncheck 甚至会尝试以结构化的格式打印页面上的数据。</code></p>
<p><strong>Displaying logical log pages</strong></p>
<p>The <strong>oncheck</strong> utility does not do much with logical log pages; it treats them as unknown page types. The reason is that logical log pages have no slot table, and when taken as a byte stream, the data on an individual log page is difficult to separate into structures and interpret. The <strong>onlog</strong> utility is a better tool for that task, for reasons that should be clearer a bit later in the course.</p>
<p><code>oncheck 工具对逻辑日志页（logical log pages）支持较少；它将这些页面视为未知类型。原因在于逻辑日志页没有slot table，而且将其作为字节流来看时，单个日志页上的数据难以划分为结构并进行解释。对于这项任务，onlog 工具更为合适，具体原因将在课程后面进一步解释。</code></p>
<p><strong>Locating partition numbers</strong></p>
<p>The <em>partition number</em> (<em>partnum</em>) uniquely identifies a specific tblspace. An unfragmented table has only one data tblspace and, therefore, has only one partition number.</p>
<p><code>partition number（partnum）用于唯一标识一个特定的 tblspace。一个未分片（unfragmented）的表只有一个数据表空间，因此也只有一个分区号。</code></p>
<p>Fragmented tables have one tblspace (and one partnum) for each dbspace fragment.</p>
<p><code>分片表中的每个 dbspace 分片都有一个对应的表空间（tblspace）和一个分区号（partnum）。</code></p>
<p>Partition numbers for unfragmented tables are stored in the <strong>systables</strong> system catalog table. Here is an example of a query to obtain a partition number in both decimal and hexadecimal format:</p>
<p><code>未分片表的分区号（partnum）存储在系统目录表 systables 中。下面是一个用于以十进制和十六进制格式获取分区号的查询示例：</code></p>
<p>deepseek：</p>
<blockquote>
<p>在数据库领域中，”catalog” 实际上就是指数据库的元数据（metadata）。</p>
<p>更具体地讲，数据库的 <strong>catalog</strong> 是由数据库系统维护的一组表或数据结构，用来描述数据库中对象的结构和属性，</p>
</blockquote>
<p>SELECT partnum, HEX(partnum) FROM systables WHERE tabname &#x3D; “<em>table_name</em>“;</p>
<p>示例：</p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505072237755.png" alt="image-20250507223709618"></p>
<p>You can also obtain a partition number for an unfragmented table by querying the <strong>sysmaster</strong> database:</p>
<p><code>您还可以通过查询 sysmaster 数据库来获取未分区表的分区号：</code></p>
<p>DATABASE sysmaster;</p>
<p>SELECT partnum, HEX(partnum) FROM systabnames WHERE tabname &#x3D; “<em>table_name</em>“;</p>
<p>示例：</p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505072238153.png" alt="image-20250507223809100"></p>
<p>If a table is fragmented, the value in the <strong>partnum</strong> column of <strong>systables</strong> and <strong>systabnames</strong> is zero. To obtain a list of partnums for a fragmented table, it is necessary to query the <strong>sysfragments</strong> system catalog:</p>
<p><code>如果表是分片的，则 systables 和 systabnames 中 partnum 列的值为零。要获取分片表的 partnum 列表，必须查询 sysfragments ：</code></p>
<p>SELECT partn, HEX(partn) FROM systables t, sysfragments f WHERE t.tabid &#x3D; f.tabid AND tabname &#x3D; “<em>table_name</em>“;</p>
<p>示例：</p>
<p>CREATE TABLE f1 (<br>    id int,<br>    name VARCHAR(10)<br>)<br>FRAGMENT BY EXPRESSION<br>    id &lt; 10 IN datadbs1,<br>    id &gt;&#x3D; 10 AND id &lt; 20 IN datadbs2,<br>    id &gt;&#x3D; 20 IN datadbs3;</p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505072253021.png" alt="image-20250507225315967"></p>
<p>Perhaps the easiest way to find a list of all partnums associated with a table (including partition numbers for index partitions) is by using the <strong>oncheck -pt</strong> command:</p>
<p><code>要查找与表相关的所有分区号列表（包括索引分区的分区号），最简单的方法可能是使用 oncheck -pt 命令：</code></p>
<p>oncheck -pt <em>database_name</em>:<em>table_name</em></p>
<p>Partition numbers are displayed under the heading <strong>Partition partnum</strong> in decimal format.</p>
<p><code>分区编号以十进制格式显示在分区 partnum 标题下。</code></p>
<p>示例：</p>
<blockquote>
<p>[root@frh gbase]# oncheck -pt testdb:f1</p>
<p>TBLspace Report for testdb:root.f1</p>
<pre><code>              Table fragment partition datadbs1 in DBspace datadbs1

Physical Address               4:5
Creation date                  05/07/2025 07:51:07
TBLspace Flags                 902        Row Locking
                                          TBLspace contains VARCHARS
                                          TBLspace use 4 bit bit-maps
Maximum row size               16
Number of special columns      1
Number of keys                 0
Number of extents              1
Current serial value           1
Current SERIAL8 value          1
Current BIGSERIAL value        1
Current REFID value            1
Pagesize (k)                   2
First extent size              8
Next extent size               8
Number of pages allocated      8
Number of pages used           2
Number of data pages           1
Number of rows                 1
Partition partnum              4194306
Partition lockid               4194306

Extents
     Logical Page     Physical Page        Size Physical Pages
                0              4:53           8          8

              Table fragment partition datadbs2 in DBspace datadbs2

Physical Address               5:5
Creation date                  05/07/2025 07:51:07
TBLspace Flags                 902        Row Locking
                                          TBLspace contains VARCHARS
                                          TBLspace use 4 bit bit-maps
Maximum row size               16
Number of special columns      1
Number of keys                 0
Number of extents              1
Current serial value           1
Current SERIAL8 value          1
Current BIGSERIAL value        1
Current REFID value            1
Pagesize (k)                   2
First extent size              8
Next extent size               8
Number of pages allocated      8
Number of pages used           2
Number of data pages           1
Number of rows                 1
Partition partnum              5242882
Partition lockid               4194306

Extents
     Logical Page     Physical Page        Size Physical Pages
                0              5:53           8          8

              Table fragment partition datadbs3 in DBspace datadbs3

Physical Address               6:5
Creation date                  05/07/2025 07:51:07
TBLspace Flags                 902        Row Locking
                                          TBLspace contains VARCHARS
                                          TBLspace use 4 bit bit-maps
Maximum row size               16
Number of special columns      1
Number of keys                 0
Number of extents              1
Current serial value           1
Current SERIAL8 value          1
Current BIGSERIAL value        1
Current REFID value            1
Pagesize (k)                   2
First extent size              8
Next extent size               8
Number of pages allocated      8
Number of pages used           2
Number of data pages           1
Number of rows                 1
Partition partnum              6291458
Partition lockid               4194306

Extents
     Logical Page     Physical Page        Size Physical Pages
                0              6:53           8          8
</code></pre>
</blockquote>
<p><strong>oncheck -pP&#x2F;pp</strong></p>
<p>The syntax to use with <strong>oncheck -pP</strong> is shown in the slide above. For example, to display page 0 from chunk 1, type:</p>
<p><code>使用 oncheck -pP 的语法如上图所示。例如，要显示chunk 1 的第 0 页，请键入</code></p>
<p>oncheck -pP 1 0</p>
<p>To display logical page 0 (the first bitmap page) from partition number 0x0100022, type:</p>
<p><code>要显示分区号 0x0100022 的逻辑页 0（第一个位图页），请键入</code></p>
<p>oncheck -pp 0x0100022 0</p>
<p>这块只是介绍一下这2命令，下面有详细介绍</p>
<p><strong>Logical page numbers</strong></p>
<p>Picture all the pages in a table lined up in chronological order and numbered, starting with 0. These would be their <em>logical page numbers</em>. If this is a confusing concept at the moment, do not worry. You will be examining tblspaces further in a later module.</p>
<p><code>想象一下，所有页面在一个表格中按时间顺序排列，并从0开始编号。这些编号就是它们的逻辑页码。如果你现在对这个概念感到困惑，不用担心——你将在后续的模块中进一步学习表空间（tblspaces）。</code></p>
<p><strong>Note</strong></p>
<p>In rare cases, the data on a particular page is formatted differently by <strong>oncheck</strong> depending on the option used. For instance, the <strong>-pP</strong> option displays only the page header for a bitmap page, but the <strong>-pp</strong> option displays the bit values in a more readable format.</p>
<p><code>在极少数情况下，oncheck 会根据所使用的选项对特定页面上的数据进行不同的格式化处理。例如，-pP 选项只显示位图页面的页头，而 -pp 选项则以更易读的格式显示位值。</code></p>
<p>There is one more variation on the <strong>oncheck -pp</strong> syntax that we have not mentioned because in fact, we do not recommend that you use it. In the spirit of providing you every tool we can think of, here it is:</p>
<p><code>oncheck -pp 语法还有一个变种，我们没有提及，因为事实上我们</code><mark>不建议你使用它</mark><code>。本着为您提供我们所能想到的所有工具的精神，我们在此介绍它：</code></p>
<p>oncheck -pp <em>database</em>:<em>table_name rowid</em></p>
<p>Only rowids above 0x100 work with this syntax; you cannot display the first bitmap page (0x100), but all other used pages in the table are fair game. For example:</p>
<p><code>只有大于 0x100 的 rowid 才能使用这种语法；你无法显示第一个位图页（0x100），但表中所有其他已使用的页面都可以显示。例如：</code></p>
<p>oncheck -pp stores_demo:customer 0x201</p>
<p>Now, you might expect the above command to display only one row from the <strong>stores_demo:customer</strong> table, the first slot on logical page 2. In fact, that command displays all rows on page 2. It is equivalent to the command:</p>
<p><code>现在，你可能以为上述命令只会显示 stores_demo:customer 表中的一条记录，即逻辑页面 2 的第一个slot。事实上，该命令会显示第 2 页上的所有行。它等同于以下命令</code></p>
<p>oncheck -pp 0x10001a 0x2</p>
<p>(assuming the partition number for the <strong>stores_demo:customer</strong> table is 0x10001a).</p>
<p><code>假设stores_demo:customer表的分区编号为 0x10001a</code></p>
<p>The advantage, of course, is that you do not need to determine the partnum for a table in order to use <strong>oncheck -pp</strong>.</p>
<p><code>当然，这样做的好处是，在使用 oncheck -pp 时不需要确定表的partnum。</code></p>
<p>The disadvantage in using this syntax is that using a rowid with <strong>oncheck</strong> and receiving output for an entire page might slow your efforts to understand the meaning of a rowid.</p>
<p><code>使用这种语法的一个缺点是，当你在 oncheck 中使用 rowid 并获得整个页面的输出时，可能会降低你理解 rowid 含义的效率。</code></p>
<p>While it is tempting to avoid working with partition numbers, the relationship between a tblspace and its partnum is extremely important to grasp. Until you have used the recommended syntax long enough to be tired of it, it is a good idea to spend the extra few seconds looking up a table’s partnum.</p>
<p><code>虽然避免使用分区编号很有诱惑力，但掌握 tblspace 与其 partnum 之间的关系极为重要。在使用推荐语法足够长的时间并对其感到厌倦之前，最好多花几秒钟来查找表的分区号。</code></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://frh16.github.io/2025/05/05/IX9111/2/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2025/04/26/IX9111/1/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">IX9111 - Unit 1. Introduction</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2025
        <i class="ri-heart-fill heart_icon"></i> fengrh
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>