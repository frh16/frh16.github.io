<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>IX9111 - Unit 2. The Dynamic Server Page |  blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-IX9111/2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  IX9111 - Unit 2. The Dynamic Server Page
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/05/05/IX9111/2/" class="article-date">
  <time datetime="2025-05-05T14:00:00.000Z" itemprop="datePublished">2025-05-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/IX9111/">IX9111</a>
  </div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong>Page: Smallest Unit of I&#x2F;O</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505052201901.png" alt="image-20250505220102809"></p>
<p><em>Pages</em> are the most basic unit of I&#x2F;O in Informix Dynamic Server; a server process does not read or write to a chunk in an increment smaller than a page. As often as possible, however, I&#x2F;O is performed on more than one page at a time.</p>
<p><code>在 IDS 中，页是 I/O 的最基本单位；服务进程在访问一个 chunk 时，读取或写入的最小单位就是一个页面。不过，I/O 通常会同时在多个页面上执行。</code></p>
<p>The default page size for a machine is either 2KB or 4KB depending on the platform. You can configure the page size for each dbspace to be any value from 2KB to 16KB, but the value must be divisible by the default page size.</p>
<p><code>机器的默认页面大小为 2KB 或 4KB，具体取决于平台。你可以将每个dbspace的page size配置为 2KB 至 16KB 之间的任意值，但该值必须能被默认页面大小整除。</code></p>
<p>At a binary level, each allocated page in a system contains a unique stream of data. But the structure and meaning of that data is always based on a handful of templates. This module teaches you how to recognize the structural similarities between Dynamic Server pages, and decipher the important parts of those structures. These skills help you understand Dynamic Server architecture and behavior to a degree you never thought possible.</p>
<p><code>在二进制层面上，系统中分配的每个页面都包含唯一的数据流。但这些数据的结构和含义总是基于一些模板。本模块教你如何识别 Dynamic Server 页面之间的结构相似性，并解读这些结构的重要部分。这些技能将帮助你理解 Dynamic Server 结构和行为，达到你从未想象过的程度。</code>  </p>
<p><strong>Our Imagined View of a Page</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505052211934.png" alt="image-20250505221109866"></p>
<p><code>Linux中的od命令是一个十六进制和其他进制的转换工具，它可以用于显示二进制文件的内容。-x：以十六进制的形式显示文件内容；</code></p>
<p>It is rarely convenient to picture a block of bytes as a continuous stream. Our preference is to reorganize the bytes so they can be viewed as if words are seen on a printed page.</p>
<p><code>将字节块想象成连续的数据流并不方便。我们更倾向于重新组织字节，使它们可以像印刷页面上的文字一样被查看。</code></p>
<p>In the example above, the <strong>od</strong> (octal dump) utility in UNIX and Linux displays a byte stream from a page. In this output, the numbers on the left represent byte offsets in <em>octal</em> and are not part of the data. The rest of the output is the actual stream of bytes from the <strong>rootchunk</strong>file displayed as hexadecimal values (courtesy of the <strong>-x</strong> option). Note that two hexadecimal digits (<strong>7c</strong>, for instance) represent one byte of data. Therefore, with a little counting, you can see that <strong>od</strong> displays 16 bytes of data on each line. The significance of the number 16 is that it equals 0x10 (hexadecimal 10).</p>
<p><code>在上面的示例中，UNIX 和 Linux 中的 od（八进制转储）实用程序显示了一个页面的字节流。在该输出中，左边的数字代表八进制的字节偏移量，并不是数据的一部分。输出的其余部分是以十六进制值显示的 rootchunk 文件的实际字节流（由 -x 选项提供）。请注意，两个十六进制数字（例如 7c）代表一个字节的数据。因此，只要稍微数一数，就可以看到 od 每行显示 16 个字节数据。数字 16 的意义在于它等于 0x10（十六进制 10）。</code></p>
<p>Because most programmers are familiar with this output format, we tend to picture Dynamic Server pages the same way: as a certain number of 16-byte lines. Therefore, this is the standard used in the Informix Dynamic Server course manuals.</p>
<p><code>由于大多数程序员都熟悉这种输出格式，我们往往会以同样的方式来描绘 Dynamic Server 页面：一定数量的 16 字节行。因此，这是 IDS 课程手册中使用的标准。</code>  </p>
<p><strong>Page Layout</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505052222234.png" alt="image-20250505222202164"></p>
<p>The layout of a page is shown in the slide above.</p>
<p><code>页面布局如上图所示。</code></p>
<p><strong>Page header</strong></p>
<p>The page header occupies the first 24 bytes on the page. It contains such information as the location, type, and current capacity of the page.</p>
<p><code>页头占页面的前 24 个字节。它包含页面的位置、类型和当前容量等信息。</code></p>
<p><strong>Timestamp</strong></p>
<p>Each time a page is modified, the timestamp field, located in the last 4 bytes of the page, is updated. The timestamp can be used to compare with other pages to determine which was updated most recently.</p>
<p><code>每次修改页面时，位于页面最后 4 个字节的时间戳字段都会更新。时间戳可用于与其他页面进行比较，以确定哪个页面是最近更新的。</code></p>
<p><strong>Slot table</strong></p>
<p>The slot table enables the database server to quickly find data on a page. It is a series of 4-byte entries that begins at the page-ending timestamp and grows toward the beginning of the page. Each entry in the table describes one <em>slot</em> on the page, which can contain a data row, or some other structure. A slot table entry is comprised of two parts: the location of the slot’s first byte and the length of the slot. A slot table entry functions as a kind of pointer, allowing direct, random access to slots on the page.</p>
<p><code>槽表使数据库服务能够快速查找页面上的数据。它是一系列 4 字节的条目，从页面结束的时间戳开始，向页面的开头延伸。表中的每个条目描述页面上的一个槽，其中可以包含数据行或其他结构。槽表项由两部分组成：槽的第一个字节位置和槽的长度。槽表项作为一种指针，允许直接随机访问页面上的槽。</code></p>
<p>Page types that tend to be searched sequentially do not utilize a slot table, although they can have one. Logical log pages are an example of a page type that has no slot table at all.</p>
<p><code>倾向于按顺序搜索的页面类型不使用slot table，尽管它们可以有slot table。逻辑日志页就是完全没有slot table的页面类型。</code></p>
<p>紫本177页：</p>
<p><code>slots table：为 slots 描述信息，数据页中有多少 slots，则会对应多少个 slots bitmap，每个占用 4 Byte，记录 slots 在页内的偏移地址和长度，当记录被删除时，只是将其中的占用长度设置为 0，在物理上并没有将记录信息清空。</code></p>
<p><strong>Page Header Overview</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505052238924.png" alt="image-20250505223812841"></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505052240740.png" alt="image-20250505224026671"></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505052241776.png" alt="image-20250505224107724"></p>
<p>The <strong>pg_offset</strong> field contains the <em>page offset</em>, which indicates the physical location of the page within the chunk.</p>
<p><code>pg_offset 字段包含页面偏移量，表示页面在chunk中的物理位置。</code></p>
<p>The page offset value is incremented by one for each subsequent page in the chunk. The first page in a chunk has a <strong>pg_offset</strong> value of 0. The maximum <strong>pg_offset</strong> value is based on the maximum size of a chunk, which is around 4 terabytes.</p>
<p><code>页偏移值每增加一页，页面偏移值就递增一次。chunk中的第一个页面的 pg_offset 值为 0。 最大 pg_offset 值基于chunk的最大大小，约为 4 TB。</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505052245545.png" alt="image-20250505224529492"></p>
<p><strong>Chunk number</strong></p>
<p>The <strong>pg_chunk</strong> field contains the number of the chunk where the page is located. Chunk numbering starts at 1. The combination of the <strong>pg_chunk</strong> and <strong>pg_offset</strong> provide all the information needed to identify the <em>page address</em>. The maximum <strong>pg_chunk</strong> value is 32,767.</p>
<p><code>pg_chunk 字段包含页面所在chunk的编号，chunk编号从 1 开始。pg_chunk 和 pg_offset 的组合提供了识别页面地址所需的全部信息。pg_chunk 的最大值为 32,767。</code></p>
<p>紫本176页：</p>
<p>Page Address ： 存 储 页 的 地 址 信 息 ， 占 用 6 Byte ， 由 两 部 分 组 成 ：chunknum+pageoffsize，其中 chunknum 占用 2 Byte，包含了符号位，故支持的最大 chunk 数为 FFFF&#x2F;2&#x3D;32767，也就是说一个 GBase 8t 实例最多可以支持 32767个 chunk。Pageoffzie 占用 4 Byte，故一个 chunk 的最大页数 FFFFFFFF 去掉符号位&#x3D;2 的 31 次方＝2 billion，对于 2k 的 pagesize，最大的空间为 4T&#x3D;22 的 31 次方*2K&#x3D;2 147 483 648*2k。</p>
<p><strong>Page checksum</strong></p>
<p>The <strong>pg_cksum</strong> field stores a checksum value that is used to validate the consistency of a page.</p>
<p><code>pg_cksum 字段存储一个校验和值，用于验证页面的一致性。</code></p>
<p>紫本：CHKSUM：校验位，占用 2 Byte。</p>
<p><strong>Number of Slots</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505062019861.png" alt="image-20250506201908729"></p>
<p>You might expect <strong>pg_nslots</strong> to equal the number of active (undeleted) slots on a page. But in fact, <strong>pg_nslots</strong> indicates the <em>highest</em> number of active slots on the page.</p>
<p><code>你可能会认为 pg_nslots 的值等于页面上活动（未被删除）slot的数量。但实际上，pg_nslots 表示的是页面上曾经出现过的最高活动slot编号。。</code></p>
<p>The <strong>pg_nslots</strong> field is not decremented, even if slots are deleted. Take the case of a data page, for example. If slots 1 through 4 out of a total of five slots are deleted, slot 5 cannot be made slot 1 in the interest of space efficiency because the rowid for that slot would change. Even though only one slot is active on the page at that point, <strong>pg_nslots</strong> must remain 5 to enable a sequential scan (which does not care about rowids) to search far enough into the slot table.</p>
<p><code>字段 pg_nslots即使在删除了slot之后也不会减少。以一个数据页为例，假设在总共五个slot中，slot 1到4被删除，那么slot 5也不能为了节省空间而变成slot 1，因为这样会导致该slot的 rowid发生变化。尽管此时这个数据页上只剩下一个有效插槽，pg_nslots 仍必须保持为5，以便顺序扫描（这种扫描方式不关心 rowid）时可以搜索到足够深的位置，访问插槽表中的所有项。</code></p>
<p><strong>Maximum number of slots</strong></p>
<p>The maximum number of slots for a data page is 255.</p>
<p><code>数据页的最大slot数为 255 。</code></p>
<p><strong>Page Flags (Type)</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505062044751.png" alt="image-20250506204451656"></p>
<p>The <strong>pg_flags</strong> field contains one or more <em>page flags</em>, which are represented by hexadecimal values that are logically <em>OR</em>ed together. The values have the following meanings in Informix Dynamic Server:</p>
<p><code>pg_flags 字段包含一个或多个页面标志，这些标志由十六进制值表示，并通过逻辑 或 运算组合在一起。这些值在 IDS 中的含义如下：</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505062048500.png" alt="image-20250506204838394"></p>
<p><strong>Free Pointer and Free Count</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505062052779.png" alt="image-20250506205217703"></p>
<p>The <strong>pg_frptr</strong> (<em>free pointer</em>) field points to the first free byte <em>after</em> all of the data on a page. If the last slot on a page is occupied, the free pointer points to the position just after that slot.</p>
<p><code>pg_frptr（空闲指针）字段指向页面上所有数据之后的第一个空闲字节。如果页面上的最后一个slot已被占用，那么空闲指针就会指向该slot之后的位置。</code></p>
<p>The <strong>pg_frcnt</strong> (<em>free count</em>) field is a sum of all unused bytes on the page.</p>
<p><code>pg_frcnt（空闲数）字段表示页面上所有未使用字节的总和。</code></p>
<p>紫本上这两个位置写的是Pfree和Nfree，和IX9111不一致</p>
<p><strong>Next Pointer and Previous Pointer</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505062058207.png" alt="image-20250506205843125"></p>
<p>The last two 4-byte elements in the page header structure are not always populated. Their main use is as node pointers on index pages. On an index page, also referred to as an index <em>node</em>, these pointers contain the logical page numbers of the two adjacent nodes. The <em>next pointer</em> (<strong>pg_next</strong>) contains the logical page number of the node to the <em>right</em>(containing higher key values), while the <em>previous pointer</em> (<strong>pg_prev</strong>) contains the logical page number of the node to the <em>left</em> (containing lower key values).</p>
<p><code>页头结构中最后两个 4 字节的元素并不总是被填充。它们的主要用途是在索引页中充当节点指针。在索引页中（也称为索引节点），这些指针包含两个相邻节点的逻辑页号。pg_next 指针包含右侧节点（包含较大键值）的逻辑页号，而 pg_prev 指针则包含左侧节点（包含较小键值）的逻辑页号。</code></p>
<p>The difference between physical and logical page numbers, and the B+ tree concepts of right and left index nodes, are explained in later modules.</p>
<p><code>物理页号与逻辑页号之间的区别，以及 B+ 树中右侧和左侧索引节点的概念，将在后续模块中进行解释。</code></p>
<p>The next and previous-pointer elements were designed into the page-header structure for use in index pages. But instead of wasting eight bytes in the header of all non-index pages, uses have been found for the next and previous pointers in a couple of other page types as well. Their use in logical log pages and tape-header pages, for example, are explained in later modules.</p>
<p><code>next 和 previous 指针元素最初是为了在索引页中使用而被设计进页头结构的。但为了避免在所有非索引页的页头中浪费这8个字节，这两个指针也被用于其他几种页面类型。例如，它们在逻辑日志页和磁带头页中的用途将在后续模块中进行说明。</code></p>
<p>紫本：</p>
<p>Next Page：占用4 Byte，指向下页的地址，对于数据页为0，对于索引页则指向下一个节点。</p>
<p>Previous Page：占用4 Byte，指向上页的地址，对于数据页为0，对于索引页则存储前页地址。</p>
<p><strong>Big Pages</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505062110830.png" alt="image-20250506211014737"></p>
<p>The default page size used for your Informix Dynamic Server instance is either 2K or 4K, depending on the platform (machine and operating system) you are using. For example, a 4K page size is the default for Windows and IBM AIX, and a 2K page size is the default for most other platforms. The root dbspace is always created using the default page size.</p>
<p><code> IDS 实例的默认页面大小是 2K 或 4K，具体取决于所使用的平台（包括机器和操作系统）。例如，Windows 和 IBM AIX 平台的默认页面大小是 4K，而大多数其他平台的默认页面大小是 2K。</code><mark>root dbspace 总是使用默认的页面大小创建。</mark></p>
<p>When you add dbspaces, you can specify a different page size using a multiple of the default page size with a maximum size of 16 kilobytes. Before you create a dbspace that uses a larger page size, you will want to configure a separate buffer pool for that page size. Configure a new buffer pool by setting the BUFFERPOOL configuration parameter. For example:</p>
<p><code>当你添加 dbspace 时，可以使用默认页面大小的倍数来指定不同的页面大小，最大支持 16KB。在创建使用较大页面大小的 dbspace 之前，建议先为该页面大小配置一个单独的缓冲池。你可以通过设置 BUFFERPOOL 配置参数来配置新的缓冲池。例如：</code></p>
<p>BUFFERPOOL <strong>size&#x3D;8k</strong>,buffers&#x3D;2000,lrus&#x3D;8,lru_min_dirty&#x3D;50,lru_max_dirty&#x3D;60</p>
<p>When the new buffer pool has been created, you can then create a dbspace using the larger page size. For example:</p>
<p><code>当新的缓冲池创建完成后，你就可以使用更大的页面大小来创建 dbspace。例如：</code></p>
<p>onspaces -c -d dbsp_bigp <strong>-k 8K</strong> -p &#x2F;opt&#x2F;dbsp3 -o 0 -s 8000</p>
<p><strong>Displaying a Page</strong></p>
<ul>
<li>Oncheck commands</li>
</ul>
<p>oncheck -pP chunk_number page_offset</p>
<p>oncheck -pp partition_number logical_page_number</p>
<ul>
<li>Chunk numbers are indexed from 1</li>
</ul>
<p><code>chunk号从1开始</code></p>
<ul>
<li>Both the page offset into a chunk and the logical page number within a table are indexed from 0</li>
</ul>
<p><code>chunk中的页面偏移量和表中的逻辑页面号都是从 0 开始的</code></p>
<ul>
<li>To obtain a partition number:</li>
</ul>
<p>– Query <strong>systables</strong> (or <strong>sysmaster:systabnames</strong>) if the table is not fragmented</p>
<p>– Query <strong>sysfragments</strong> if the table is fragmented</p>
<p>– Run <strong>oncheck -pt</strong> to find all partnums of all fragments</p>
<ul>
<li>The <strong>oncheck</strong> utility recognizes both decimal (100) and hexadecimal (0x64) format for its arguments</li>
</ul>
<p><code>oncheck 工具支持十进制（100）和十六进制（0x64）格式的参数。</code></p>
<p>When logged on as either <em>root</em> or <em>informix</em>, you can display most pages within an Informix Dynamic Server chunk using the <strong>oncheck</strong> utility. Based on the type of page it finds, <strong>oncheck</strong> even attempts to print the data on the page in an organized format.</p>
<p><code>当以 root 用户或 informix 用户登录时，可以使用 oncheck 工具查看 IDS chunk中的大多数页面。根据所找到的页面类型，oncheck 甚至会尝试以结构化的格式打印页面上的数据。</code></p>
<p><strong>Displaying logical log pages</strong></p>
<p>The <strong>oncheck</strong> utility does not do much with logical log pages; it treats them as unknown page types. The reason is that logical log pages have no slot table, and when taken as a byte stream, the data on an individual log page is difficult to separate into structures and interpret. The <strong>onlog</strong> utility is a better tool for that task, for reasons that should be clearer a bit later in the course.</p>
<p><code>oncheck 工具对逻辑日志页（logical log pages）支持较少；它将这些页面视为未知类型。原因在于逻辑日志页没有slot table，而且将其作为字节流来看时，单个日志页上的数据难以划分为结构并进行解释。对于这项任务，onlog 工具更为合适，具体原因将在课程后面进一步解释。</code></p>
<p><strong>Locating partition numbers</strong></p>
<p>The <em>partition number</em> (<em>partnum</em>) uniquely identifies a specific tblspace. An unfragmented table has only one data tblspace and, therefore, has only one partition number.</p>
<p><code>partition number（partnum）用于唯一标识一个特定的 tblspace。一个未分片（unfragmented）的表只有一个数据表空间，因此也只有一个分区号。</code></p>
<p>Fragmented tables have one tblspace (and one partnum) for each dbspace fragment.</p>
<p><code>分片表中的每个 dbspace 分片都有一个对应的表空间（tblspace）和一个分区号（partnum）。</code></p>
<p>Partition numbers for unfragmented tables are stored in the <strong>systables</strong> system catalog table. Here is an example of a query to obtain a partition number in both decimal and hexadecimal format:</p>
<p><code>未分片表的分区号（partnum）存储在系统目录表 systables 中。下面是一个用于以十进制和十六进制格式获取分区号的查询示例：</code></p>
<p>deepseek：</p>
<blockquote>
<p>在数据库领域中，”catalog” 实际上就是指数据库的元数据（metadata）。</p>
<p>更具体地讲，数据库的 <strong>catalog</strong> 是由数据库系统维护的一组表或数据结构，用来描述数据库中对象的结构和属性，</p>
</blockquote>
<p>SELECT partnum, HEX(partnum) FROM systables WHERE tabname &#x3D; “<em>table_name</em>“;</p>
<p>示例：</p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505072237755.png" alt="image-20250507223709618"></p>
<p>You can also obtain a partition number for an unfragmented table by querying the <strong>sysmaster</strong> database:</p>
<p><code>您还可以通过查询 sysmaster 数据库来获取未分区表的分区号：</code></p>
<p>DATABASE sysmaster;</p>
<p>SELECT partnum, HEX(partnum) FROM systabnames WHERE tabname &#x3D; “<em>table_name</em>“;</p>
<p>示例：</p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505072238153.png" alt="image-20250507223809100"></p>
<p>If a table is fragmented, the value in the <strong>partnum</strong> column of <strong>systables</strong> and <strong>systabnames</strong> is zero. To obtain a list of partnums for a fragmented table, it is necessary to query the <strong>sysfragments</strong> system catalog:</p>
<p><code>如果表是分片的，则 systables 和 systabnames 中 partnum 列的值为零。要获取分片表的 partnum 列表，必须查询 sysfragments ：</code></p>
<p>SELECT partn, HEX(partn) FROM systables t, sysfragments f WHERE t.tabid &#x3D; f.tabid AND tabname &#x3D; “<em>table_name</em>“;</p>
<p>示例：</p>
<p>CREATE TABLE f1 (<br>    id int,<br>    name VARCHAR(10)<br>)<br>FRAGMENT BY EXPRESSION<br>    id &lt; 10 IN datadbs1,<br>    id &gt;&#x3D; 10 AND id &lt; 20 IN datadbs2,<br>    id &gt;&#x3D; 20 IN datadbs3;</p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505072253021.png" alt="image-20250507225315967"></p>
<p>Perhaps the easiest way to find a list of all partnums associated with a table (including partition numbers for index partitions) is by using the <strong>oncheck -pt</strong> command:</p>
<p><code>要查找与表相关的所有分区号列表（包括索引分区的分区号），最简单的方法可能是使用 oncheck -pt 命令：</code></p>
<p>oncheck -pt <em>database_name</em>:<em>table_name</em></p>
<p>Partition numbers are displayed under the heading <strong>Partition partnum</strong> in decimal format.</p>
<p><code>分区编号以十进制格式显示在分区 partnum 标题下。</code></p>
<p>示例：</p>
<blockquote>
<p>[root@frh gbase]# oncheck -pt testdb:f1</p>
<p>TBLspace Report for testdb:root.f1</p>
<pre><code>              Table fragment partition datadbs1 in DBspace datadbs1

Physical Address               4:5
Creation date                  05/07/2025 07:51:07
TBLspace Flags                 902        Row Locking
                                          TBLspace contains VARCHARS
                                          TBLspace use 4 bit bit-maps
Maximum row size               16
Number of special columns      1
Number of keys                 0
Number of extents              1
Current serial value           1
Current SERIAL8 value          1
Current BIGSERIAL value        1
Current REFID value            1
Pagesize (k)                   2
First extent size              8
Next extent size               8
Number of pages allocated      8
Number of pages used           2
Number of data pages           1
Number of rows                 1
Partition partnum              4194306
Partition lockid               4194306

Extents
     Logical Page     Physical Page        Size Physical Pages
                0              4:53           8          8

              Table fragment partition datadbs2 in DBspace datadbs2

Physical Address               5:5
Creation date                  05/07/2025 07:51:07
TBLspace Flags                 902        Row Locking
                                          TBLspace contains VARCHARS
                                          TBLspace use 4 bit bit-maps
Maximum row size               16
Number of special columns      1
Number of keys                 0
Number of extents              1
Current serial value           1
Current SERIAL8 value          1
Current BIGSERIAL value        1
Current REFID value            1
Pagesize (k)                   2
First extent size              8
Next extent size               8
Number of pages allocated      8
Number of pages used           2
Number of data pages           1
Number of rows                 1
Partition partnum              5242882
Partition lockid               4194306

Extents
     Logical Page     Physical Page        Size Physical Pages
                0              5:53           8          8

              Table fragment partition datadbs3 in DBspace datadbs3

Physical Address               6:5
Creation date                  05/07/2025 07:51:07
TBLspace Flags                 902        Row Locking
                                          TBLspace contains VARCHARS
                                          TBLspace use 4 bit bit-maps
Maximum row size               16
Number of special columns      1
Number of keys                 0
Number of extents              1
Current serial value           1
Current SERIAL8 value          1
Current BIGSERIAL value        1
Current REFID value            1
Pagesize (k)                   2
First extent size              8
Next extent size               8
Number of pages allocated      8
Number of pages used           2
Number of data pages           1
Number of rows                 1
Partition partnum              6291458
Partition lockid               4194306

Extents
     Logical Page     Physical Page        Size Physical Pages
                0              6:53           8          8
</code></pre>
</blockquote>
<p><strong>oncheck -pP&#x2F;pp</strong></p>
<p>The syntax to use with <strong>oncheck -pP</strong> is shown in the slide above. For example, to display page 0 from chunk 1, type:</p>
<p><code>使用 oncheck -pP 的语法如上图所示。例如，要显示chunk 1 的第 0 页，请键入</code></p>
<p>oncheck -pP 1 0</p>
<p>To display logical page 0 (the first bitmap page) from partition number 0x0100022, type:</p>
<p><code>要显示 partition number 0x0100022 的逻辑页 0（第一个位图页），请键入</code></p>
<p>oncheck -pp 0x0100022 0</p>
<p>这块只是介绍一下这2命令，下面有详细介绍</p>
<p><strong>Logical page numbers</strong></p>
<p>Picture all the pages in a table lined up in chronological order and numbered, starting with 0. These would be their <em>logical page numbers</em>. If this is a confusing concept at the moment, do not worry. You will be examining tblspaces further in a later module.</p>
<p><code>想象一下，所有页面在一个表格中按时间顺序排列，并从0开始编号。这些编号就是它们的逻辑页码。如果你现在对这个概念感到困惑，不用担心——你将在后续的模块中进一步学习表空间（tblspaces）。</code></p>
<p><strong>Note</strong></p>
<p>In rare cases, the data on a particular page is formatted differently by <strong>oncheck</strong> depending on the option used. For instance, the <strong>-pP</strong> option displays only the page header for a bitmap page, but the <strong>-pp</strong> option displays the bit values in a more readable format.</p>
<p><code>在极少数情况下，oncheck 会根据所使用的选项对特定页面上的数据进行不同的格式化处理。例如，-pP 选项只显示位图页面的页头，而 -pp 选项则以更易读的格式显示位值。</code></p>
<p>应该要到Unit 4才能知道bitmap page是什么，先不用管他</p>
<p>There is one more variation on the <strong>oncheck -pp</strong> syntax that we have not mentioned because in fact, we do not recommend that you use it. In the spirit of providing you every tool we can think of, here it is:</p>
<p><code>oncheck -pp 语法还有一个变种，我们没有提及，因为事实上我们</code><mark>不建议你使用它</mark><code>。本着为您提供我们所能想到的所有工具的精神，我们在此介绍它：</code></p>
<p>oncheck -pp <em>database</em>:<em>table_name rowid</em></p>
<p>Only rowids above 0x100 work with this syntax; you cannot display the first bitmap page (0x100), but all other used pages in the table are fair game. For example:</p>
<p><code>只有大于 0x100 的 rowid 才能使用这种语法；你无法显示第一个位图页（0x100），但表中所有其他已使用的页面都可以显示。例如：</code></p>
<p>oncheck -pp stores_demo:customer 0x201</p>
<p>Now, you might expect the above command to display only one row from the <strong>stores_demo:customer</strong> table, the first slot on logical page 2. In fact, that command displays all rows on page 2. It is equivalent to the command:</p>
<p><code>现在，你可能以为上述命令只会显示 stores_demo:customer 表中的一条记录，即逻辑页面 2 的第一个slot。事实上，该命令会显示第 2 页上的所有行。它等同于以下命令</code></p>
<p>oncheck -pp 0x10001a 0x2</p>
<p>(assuming the partition number for the <strong>stores_demo:customer</strong> table is 0x10001a).</p>
<p><code>假设stores_demo:customer表的分区编号为 0x10001a</code></p>
<p>The advantage, of course, is that you do not need to determine the partnum for a table in order to use <strong>oncheck -pp</strong>.</p>
<p><code>当然，这样做的好处是，在使用 oncheck -pp 时不需要确定表的partnum。</code></p>
<p>The disadvantage in using this syntax is that using a rowid with <strong>oncheck</strong> and receiving output for an entire page might slow your efforts to understand the meaning of a rowid.</p>
<p><code>使用这种语法的一个缺点是，当你在 oncheck 中使用 rowid 并获得整个页面的输出时，可能会降低你理解 rowid 含义的效率。</code></p>
<p>While it is tempting to avoid working with partition numbers, the relationship between a tblspace and its partnum is extremely important to grasp. Until you have used the recommended syntax long enough to be tired of it, it is a good idea to spend the extra few seconds looking up a table’s partnum.</p>
<p><code>虽然避免使用分区编号很有诱惑力，但掌握 tblspace 与其 partnum 之间的关系极为重要。在使用推荐语法足够长的时间并对其感到厌倦之前，最好多花几秒钟来查找表的分区号。</code></p>
<blockquote>
<p>tempting</p>
<p>英[ˈtemptɪŋ]    美[ˈtemptɪŋ]<br>adj.诱人的;吸引人的;有吸引力的;v.诱惑;引诱;怂恿;利诱;劝诱;鼓动;</p>
<p>extremely</p>
<p>英[ɪkˈstriːmli]   美[ɪkˈstriːmli] </p>
<p>adv.极其;非常;极端;</p>
<p>grasp</p>
<p>英[ɡrɑːsp]    美[ɡræsp]<br>vt.抓住;理解;领会;领悟;抓牢;毫不犹豫地抓住(机会);n.理解(力);控制;领会;紧握;紧抓;能力所及;</p>
</blockquote>
<p>实际使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@frh gbase]<span class="comment"># oncheck -pp 0x00D00047 0</span></span><br><span class="line">addr             stamp    chksum nslots flag <span class="built_in">type</span>         frptr frcnt next     prev</span><br><span class="line">13:2087          8188418  fa54   0      804  FREE         24    2020  0        0</span><br><span class="line">   0:8 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line"></span><br><span class="line">[root@frh gbase]<span class="comment"># oncheck -pp 0x00D00047 1</span></span><br><span class="line">addr             stamp    chksum nslots flag <span class="built_in">type</span>         frptr frcnt next     prev</span><br><span class="line">13:2088          8187311  e5f6   2      801  DATA         42    1994  0        0</span><br><span class="line">        slot ptr   len   flg</span><br><span class="line">        1    24    9     0</span><br><span class="line">        2    33    9     0</span><br><span class="line">slot   1:</span><br><span class="line">    0:  0  0  0  1  0  3 61 61 61                        ......aaa.......</span><br><span class="line">slot   2:</span><br><span class="line">    0:  0  0  0  2  0  3 62 62 62                        ......bbb.......</span><br></pre></td></tr></table></figure>

<p>不知道为什么从1开始</p>
<blockquote>
<p>chatgpt：</p>
<p>这是 <strong>Informix 的分区结构（partition）设计</strong>所决定的：</p>
<h4 id="每个-partition（partnum-对应的分片）中的："><a href="#每个-partition（partnum-对应的分片）中的：" class="headerlink" title="每个 partition（partnum 对应的分片）中的："></a>每个 partition（partnum 对应的分片）中的：</h4><ul>
<li><strong>逻辑页 0</strong> 是所谓的 <strong>partition header page</strong>（也叫 <code>partn page</code>）；<ul>
<li>它保存了该分区的元信息，如 extent 列表、分片状态等；</li>
<li>不是用来存储行数据的；</li>
</ul>
</li>
<li><strong>逻辑页 1 开始</strong> 才是实际存储数据的页（如果有）；<ul>
<li>数据行通常从逻辑页 1、2、3 开始向后分布；</li>
<li>这些页才是你期望看到的表行内容页。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>Displaying a Big Page</strong></p>
<p>先看下边Notes</p>
<ul>
<li>Calculate page offset:</li>
</ul>
<p>pg_offset &#x3D; (chunk_pgsize &#x2F; system_pgsize) * page_num</p>
<ul>
<li>Example: To dump page 15 of chunk 3 on AIX (default page size &#x3D; 4K) with a configured page size of 16K for chunk 3:</li>
</ul>
<p>pg_offset &#x3D; (16 &#x2F; 4) * 15 &#x3D; 60</p>
<p><strong>oncheck -pP 3 60</strong></p>
<ul>
<li>Example: To dump the first partition page (page 3) on Linux (default page size &#x3D; 2) with a configured page size of 8K for chunk 3:</li>
</ul>
<p>pg_offset &#x3D; (8 &#x2F; 2) * 3 &#x3D; 12</p>
<p><strong>oncheck -pP 3 12</strong></p>
<p><strong>Notes:</strong></p>
<p>To dump a page that is larger than the default platform page size, the DBA uses the same <strong>oncheck</strong> command: <strong>oncheck -pP</strong> <strong>chunk# pg_offset</strong>, but the <em>pg_offset</em> has to be calculated differently:</p>
<p><code>要转储大于默认平台页面大小的页面，DBA 使用相同的 oncheck 命令：oncheck -pP chunk# pg_offset，但 pg_offset 的计算方式不同：</code></p>
<p>pg_offset &#x3D; (<em>chunk_pgsize</em> &#x2F; <em>system_pgsize</em>) * <em>page#</em></p>
<p>Some example calculations and <strong>oncheck</strong> commands are shown above.</p>
<p>例子在上边</p>
<p><strong>Page Header Format</strong></p>
<p>The formats used for each header element in the display are:</p>
<p><code>显示中每个标题元素所使用的格式如下：（十进制、十六进制、字符）</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505082035860.png" alt="image-20250508203538773"></p>
<p><strong>Notes:</strong></p>
<p>A page header displayed by <strong>oncheck</strong> can be frustrating to decipher at first, because the utility does not use a consistent notation for the elements. Some are displayed as hexadecimal values, some as decimals. The slide above indicates the format used for each element.</p>
<p><code>一开始，oncheck 显示的页眉可能会让人难以理解，因为该工具对元素没有使用统一的符号。有些显示为十六进制值，有些显示为小数。上面的幻灯片显示了每个元素使用的格式。</code></p>
<blockquote>
<p>frustrating<br>英[frʌˈstreɪtɪŋ] 美[ˈfrʌstreɪtɪŋ]<br>adj.令人沮丧的;令人懊恼的;  v.使沮丧;挫败;阻止;使懊恼;防止;使懊丧;</p>
<p>decipher<br>英[dɪˈsaɪfə(r)] 美[dɪˈsaɪfər]<br>vt.破译;辨认(难认、难解的东西);v.破译;n.密电(或密信)的译文;</p>
<p>notation<br>英[nəʊˈteɪʃn] 美[noʊˈteɪʃn]<br>n.符号;(数学、科学和音乐中的)记号;谱号;</p>
</blockquote>
<p>The <strong>addr</strong> column shows the chunk number (<strong>pg_chunk</strong>) and offset (<strong>pg_offset</strong>) for the page.</p>
<p><code>addr 列显示页面的块号（pg_chunk）和偏移量（pg_offset）。</code></p>
<p>The <strong>flag</strong> and <strong>type</strong> columns in the output refer to the same element in the structure: <strong>pg_flags</strong>. The <strong>type</strong> column is meant to translate the page flags into something more recognizable, though the chosen terms sometimes add to the confusion. Here are all the <strong>type</strong> values output by <strong>oncheck</strong> followed by yet another translation:</p>
<p><code>输出中的flag和type指的是结构中的同一个元素：pg_flags。type的目的是将页面标志转换成更容易辨认的内容，尽管所选术语有时会造成混淆。下面是 oncheck 输出的所有类型值，以及另一种翻译：</code></p>
<p>DATA Tblspace data page</p>
<p>PARTN Partition (tblspace tblspace) page</p>
<p>FREE Tblspace bitmap page</p>
<p>CHUNK Chunk free list page</p>
<p>REMAIN Remainder page</p>
<p>PBLOB Partition-resident BLOB page</p>
<p>BLOB BLOBspace-resident BLOB page</p>
<p>BBIT BLOB chunk free-list page</p>
<p>BMAP Blob chunk BLOB map page</p>
<p>BTREE Index page</p>
<p>ROOTRSV Root reserved page</p>
<p>UNKNOWN The default type, which includes logical log pages</p>
<p><strong>Slot Table Format</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505082115460.png" alt="image-20250508211523372"></p>
<p><strong>Notes:</strong></p>
<p>For most pages, after displaying the page header, <strong>oncheck</strong> displays the slot table if one exists. All values displayed in the slot table list are in decimal notation.</p>
<p>对于大多数页面，在显示页头后，<strong>oncheck</strong> 会显示slot table（如果存在）。slot table列表中显示的所有值都是十进制。</p>
<table>
<thead>
<tr>
<th><strong>slot</strong></th>
<th>The slot table entry (this value is not actually stored in the slot table).    表条目（该值实际上并不存储在表中）。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ptr</strong></td>
<td><strong>The byte offset into the page where the first byte of the slot is found.    在页面中找到slot第一个字节的字节偏移量。</strong></td>
</tr>
<tr>
<td><strong>len</strong></td>
<td><strong>The length of the slot in bytes.   slot的长度（字节）。</strong></td>
</tr>
<tr>
<td><strong>flg</strong></td>
<td><strong>If the slot contains a forward pointer, this value is 2; otherwise, it is 0. 如果slot包含一个前向指针，该值为 2；否则为 0。</strong></td>
</tr>
</tbody></table>
<p>Remember, a slot is not a row, but a <em>container</em>. A slot can contain a data row, a portion of a data row (in the case of a row that has been split across pages), or another structure altogether. A slot table entry consists of a length and a position on a page.</p>
<p><code>记住，slot不是行，而是容器。slot可以包含一条数据行、数据行的一部分（在数据行被分割到不同页面的情况下）或另一种结构。slot table项由长度和在页面上的位置组成。</code></p>
<p><strong>Slot Format</strong></p>
<p>The slots are displayed as streams of individual bytes. Bytes are displayed in hexadecimal format, without leading zeros (this may be a point of confusion at first).</p>
<p><code>slot显示为单个字节流。字节以十六进制格式显示，不含前导零（起初可能会引起混淆）。</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505082124609.png" alt="image-20250508212453518"></p>
<p><strong>Notes:</strong></p>
<p>After displaying the slot table, <strong>oncheck</strong> displays the slots themselves. Note that <strong>oncheck</strong>displays the bytes in each slot in hexadecimal notation, 16-across. In addition, an ASCII translation of each 16-byte <em>line</em> in the slot, or fraction thereof, is displayed to the right. Dots in the ASCII lines serve as place holders for bytes that cannot be translated into ASCII characters.</p>
<p><code>显示slot table后，oncheck 显示slot本身。请注意，oncheck 会以十六进制符号显示每个slot中的字节，16-across。此外，右侧还显示slot中每行 16 字节的 ASCII 译文或其部分。ASCII 行中的点是无法转换成 ASCII 字符的字节的占位符。</code></p>
<p>To the left of each line of bytes is an offset in decimal. This value (0, 16, 32, etc.) is the byte offset of the first byte on the line, relative to the beginning of the slot.</p>
<p><code>每行字节的左边是一个十进制偏移量。该值（0、16、32 等）是该行第一个字节相对于slot起始位置的字节偏移量。</code></p>
<p><strong>Page View</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505082133156.png" alt="image-20250508213331042"></p>
<p><strong>Notes:</strong></p>
<p>The <strong>oncheck</strong> utility attempts to display data in an easy-to read format. To see what a page really looks like, or at least the hexadecimal representation of the page, other utilities are needed. </p>
<p><code>oncheck 工具试图以易于阅读的格式显示数据。要查看页面的真实情况，或至少查看页面的十六进制表示，还需要其他实用程序。</code></p>
<p>Above is an example of a page that was extracted from an Informix Dynamic Server chunk and displayed in hexadecimal format. The <strong>dd</strong> and <strong>od</strong> commands, provided by most UNIX operating systems, were used to do this. This view of the page gives a better idea of where the page components are located.</p>
<p><code>以上是从 IDS chunk 中提取页面并以十六进制格式显示的示例。大多数 UNIX 操作系统都提供了 dd 和 od 命令。通过这种页面视图，可以更好地了解页面组件的位置。</code></p>
<p>The first column of the <strong>od -x</strong> output indicates the byte offset into the page in <em>octal</em>. Since it is easier to use hexadecimal values to identify the offsets, a hexadecimal translation is provided to the right of the example. An asterisk appears where lines of data repeat.</p>
<p><code>od -x 输出结果的第一列显示了以八进制表示的页面字节偏移量。由于使用十六进制值更容易识别偏移量，因此示例右侧提供了十六进制转换。数据行重复的地方会出现星号。</code></p>
<blockquote>
<h3 id="第一部分：dd-if-dev-chunk1-skip-123-count-1-bs-2k"><a href="#第一部分：dd-if-dev-chunk1-skip-123-count-1-bs-2k" class="headerlink" title="第一部分：dd if=/dev/chunk1 skip=123 count=1 bs=2k"></a>第一部分：<code>dd if=/dev/chunk1 skip=123 count=1 bs=2k</code></h3><p><code>dd</code> 是一个用于按块复制数据的低级工具。各个参数含义如下：</p>
<ul>
<li><code>if=/dev/chunk1</code>：<strong>输入文件</strong>（input file），这里是一个设备文件 <code>/dev/chunk1</code>。</li>
<li><code>skip=123</code>：<strong>跳过前 123 个块</strong>，不读取它们。</li>
<li><code>count=1</code>：<strong>读取 1 个块</strong>。</li>
<li><code>bs=2k</code>：<strong>每个块大小为 2KB</strong>（即 2048 字节）。</li>
</ul>
<p>➡️ 综合：这个命令会从 <code>/dev/chunk1</code> 中跳过前 123 × 2KB（即 246KB），然后读取接下来的 <strong>2KB 数据</strong>。</p>
<hr>
<h3 id="第二部分：-od-x"><a href="#第二部分：-od-x" class="headerlink" title="第二部分：| od -x"></a>第二部分：<code>| od -x</code></h3><ul>
<li><code>|</code>：管道符，将上一步 <code>dd</code> 的输出传递给下一个命令。</li>
<li><code>od</code>：<strong>octal dump</strong>（八进制转储）工具，用于以人类可读的方式查看二进制数据。</li>
<li><code>-x</code>：以 <strong>十六进制</strong>的形式显示输出。</li>
</ul>
<p>➡️ 效果：你将看到读取到的 2KB 数据的十六进制表示，通常用于调试、查看原始数据结构、分析二进制文件内容等。</p>
</blockquote>
<p><strong>Coming up next</strong></p>
<p>You now have the tools necessary to display pages based on their location in a chunk or in a tblspace. The trick, of course, is in knowing ahead of time what information is located at specific points in a chunk or tblspace. In the next two chapters, you will learn the architecture of dbspaces and tblspaces at the page level and beyond.</p>
<p><code>现在你已经拥有了根据页面在chunk或 tblspace 中的位置来显示页面所需的工具。当然，其中的诀窍在于提前知道信息位于chunk或 tblspace 中的特定位置。在接下来的两章中，你将学习 dbspaces 和 tblspaces 在页面级及以上的架构。</code></p>
<p><strong>Byte Swapping</strong></p>
<p>In a byte-swapping system, the bytes in a 2-byte and 4-byte value are reversed when saved to disk.</p>
<p><code>在字节交换系统中，2 字节和 4 字节数值的字节在保存到磁盘时会相反。</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505082142142.png" alt="image-20250508214227054"></p>
<p><strong>Notes:</strong></p>
<p>Some operating systems do not store streams of bytes in the same way that we would normally view them. On these systems, certain values go through a <em>byte-swapping</em> process before the value is written to disk. This is why the values that you may see in a hexadecimal page dump, or even in a slot table entry, may not appear the way you expect. </p>
<p><code>有些操作系统存储字节流的方式与我们通常查看字节流的方式不同。在这些系统中，某些值在写入磁盘前要经过字节交换过程。这就是为什么你在十六进制页面转储，甚至在slot table项中看到的值可能与你期望的不一样。</code></p>
<p>When a byte swap occurs, the first byte of a 2-byte value get s “swapped” with the last byte. For a 4-byte value, the first byte is swapped with the fourth byte, and the second byte is swapped with the third. An example is shown above using the octal dump shown on the previous page.</p>
<p><code>发生字节交换时，2 字节数值的第一个字节会与最后一个字节 “交换”。对于 4 字节值，第一个字节与第四个字节交换，第二个字节与第三个字节交换。上图是一个使用前一页所示八进制转储的示例。</code></p>
<p>In most cases, oncheck displays output that has been properly converted from the disk format. There are cases where slot information is displayed showing byte-swapped values.</p>
<p><code>在大多数情况下，oncheck 显示的输出已从磁盘格式正确转换。在某些情况下，显示的slot信息会显示字节交换值。</code></p>
<p>The Linux operating system, used by the lab image for this course, uses byte-swapping.</p>
<p><code>本课程实验镜像所使用的 Linux 操作系统采用字节交换（byte-swapping）机制。</code></p>
<p>补充一些紫本内容：（177页）</p>
<p>对数据部分的解释如下。</p>
<ul>
<li>在数据页中用来存储数据的部分可以存储行记录和索引 key。</li>
<li>以 slots 的方式分成 <em>n</em> 个存储单元，每个 slots 存放一行记录或者一个 index-key。</li>
<li>在一个数据页中最多能存储 255 个 slots。</li>
</ul>
<p>​		一个数据页的页头和页尾占用的总空间为 28 Byte + <em>n**4Byte，其中 <em>n</em> 为 page 中存储的记录数。如总共存储 100 个记录，那么总共占用：28+100</em>4&#x3D;428 Byte，如果为 2k 的 page，那么 100 个记录实际数据占用的空间为：2048－428＝1620 Byte。</p>
<p>​		一个 Page 中能存储多少行记录的计算公式为：28 Byte + <em>n</em> *（4+rowsize） Byte</p>
<p>​		假如表的 rowsize&#x3D;16 Byte，那么一个 pagesize 为 2KB 页刚好可以存储 101 行记录：28+101*（4+16）&#x3D;2048。</p>
<p>如果采用 pagesize 为 16K 的页来存储 rowsize&#x3D;16 Byte 的表，由于一个 page 最多存储255 行记录，那么实际使用的空间为：28 + 255*（4+16） &#x3D;5128 Byte，那么 16K 的存储Page 将有超过 10K 被浪费，也就说不同的表需要选择合理大小的 pagesize 来存储。</p>
<p>​		表 6.6 列出了采用不同 pagesize 的数据页中最多存储 255 行记录对应的 rowsize 大小。</p>
<p>​		<img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505082210927.png" alt="image-20250508221057854"></p>
<p>如表 6.6 说明了若有一个表的 rowsize 不大于 11 Byte，那么应该采用 2K 的 Pagesize；如果采用 4K 或者更大的 pagesize 那么会有空间浪费。如果一个表的 rowsize 不大于 28，那么不建议采用 8K 的 pagesize；如果表的 rowsize 不大于 60 Byte，那么不建议采用 16K 的 Pagesize。</p>
<p>假如有表 customer：</p>
<p>create table customer（cus_id integer,cus_name char（10））;</p>
<p>该表的 rowsize&#x3D;4+10&#x3D;14 Byte，那么该表建议采用不大于 4K 的 pagesize。为了更好地理解 Page 的存储结构，下面通过表 customer 的实际数据存储情况来展示数据页的内部结构。</p>
<blockquote>
<p>Drop table if exists customer;</p>
<p>Create table customer (cus_id integer,cus_name char(10)) in dbs2k;</p>
<p>Create index idx_customer on customer(cus_id);</p>
<p>Insert into customer values(1,’abc’);</p>
<p>Insert into customer values(2,’def’);</p>
</blockquote>
<p>通过 oncheck 及操作系统 od 命令查看 customer 表记录在数据页上的存储情况，如图6.27 所示。</p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505082212984.png" alt="image-20250508221231802"></p>
<p>00000043：addr的67，也就是IX9111的pg_offset，4字节</p>
<p>根据前边可知，0x101是rowid，但为什么是这个数没看到解释，我自己查的：</p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505082234005.png" alt="image-20250508223442940"></p>
<p>0x101就是257，所以第一条记录的rowid就是0x101</p>
<p>前边提到，IX9111不推荐这种写法（库名:表名），推荐用partition number</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://frh16.github.io/2025/05/05/IX9111/2/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2025/05/09/IX9111/3/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            IX9111 - Unit 3. Dbspace Layout
          
        </div>
      </a>
    
    
      <a href="/2025/04/26/IX9111/1/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">IX9111 - Unit 1. Introduction</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2025
        <i class="ri-heart-fill heart_icon"></i> fengrh
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>