<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>IX9111 - Unit 3. Dbspace Layout |  blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-IX9111/3"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  IX9111 - Unit 3. Dbspace Layout
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/05/09/IX9111/3/" class="article-date">
  <time datetime="2025-05-09T13:44:05.000Z" itemprop="datePublished">2025-05-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/IX9111/">IX9111</a>
  </div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong>A Hypothetical Root Dbspace</strong></p>
<p>一个假想的root dbspace</p>
<blockquote>
<p>hypothetical<br>英[ˌhaɪpəˈθetɪkl]  美[ˌhaɪpəˈθetɪkl]<br>adj.（基于）假设的，假定的;有待证实的;</p>
</blockquote>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505092150641.png" alt="image-20250509215037499"></p>
<p><strong>Notes:</strong></p>
<p>The root dbspace is an Informix database server’s first and most critical dbspace. It contains the system’s first chunk, the <em>root chunk</em>. As with other dbspaces, additional chunks can be added over time. Since the root dbspace as a whole can never be dropped, the initial chunk for the root dbspace should be configured wisely.</p>
<p><code>root dbspace是 IDS 的第一个也是最关键的数据库空间。它包含系统的第一个数据块，即 root chunk。与其他数据库空间一样，随着时间的推移还可以添加其他块。由于根数据库空间作为一个整体永远不会被删除，因此应明智地配置根数据库空间的初始块。</code></p>
<blockquote>
<p>wisely<br>英[ˈwaɪzli] 美[ˈwaɪzli]<br>adv.明智地;</p>
</blockquote>
<p>You normally do not keep databases in the root dbspace. Data should be spread across multiple disks, and to do that you should create multiple dbspaces and assign tables to specific dbspaces (or fragment a table across dbspaces).</p>
<p><code>通常情况下，不会在root dbspace中保存数据库。数据应分布在多个磁盘上，为此应创建多个dbspace，并将表分配到特定的dbspace（或将表分片到不同的dbspace）。</code></p>
<p>Initially, the physical log and at least three logical logs are located in the root dbspace. During the tuning phase, these are normally recreated in other dbspaces to take advantage of additional disk drives.</p>
<p><code>最初，物理日志和至少三个逻辑日志位于root dbspace。在调整阶段，通常会在其他dbspace重新创建这些日志，以利用额外的磁盘驱动器。</code></p>
<blockquote>
<p>tuning<br>英[ˈtjuːnɪŋ]美[ˈtuːnɪŋ]<br>v.(给收音机、电视等)调谐，调频道;调整，调节(发动机);(为乐器)调音，校音;<br>n.【无线】调谐；收听；【乐】调音[弦];</p>
</blockquote>
<p><strong>Layout of a Root Chunk</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505092202432.png" alt="image-20250509220256358"></p>
<p><strong>Notes:</strong></p>
<p>After a complete disk initialization and before a system is tuned, the layout of the root chunk looks similar to the one pictured above.</p>
<p><code>在完成磁盘初始化后和系统调整前，root chunk的布局与上图类似。</code></p>
<p><strong>Reserved pages</strong></p>
<p>The first twelve pages of the initial chunk in the root dbspace are the system <em>reserved</em> <em>pages</em>, which are used for system-tracking information and are updated during each checkpoint. Beginning with the third reserved page, the pages are organized into semi-redundant pairs, each of which stores a distinct type of structure, with the pages in each pair taking turns as the more current version.</p>
<p><code>root dbspace中初始块的前十二页是系统保留页，用于系统跟踪信息，并在每次检查点时更新。从第三个保留页面开始，页面被组织成半冗余对，每个对存储一种不同类型的结构，每个对中的页面轮流作为最新版本。</code></p>
<blockquote>
<p>semi<br>英[ˈsemi]  美[ˈsemi]<br>n. 半决赛;半独立式住宅;</p>
<p>redundant<br>英[rɪˈdʌndənt]  美[rɪˈdʌndənt]<br>adj.冗余的;多余的;不需要的;被裁减的;</p>
</blockquote>
<p><strong>Chunk free list</strong></p>
<p>In every chunk, the page following the reserved pages is a chunk free-list page. A chunk free-list page contains information about free extents (groups of contiguous free pages) in the chunk.</p>
<p><code>在每个chunk中，保留页之后的页面是chunk free list page。chunk free list page包含分chunk中空闲extents（由连续空闲页组成）的信息。</code></p>
<p><strong>Tblspace tblspace</strong></p>
<p>A tblspace tblspace is a collection of pages that describes the location and structure of all tblspaces in a particular dbspace. Most pages in the tblspace tblspace have the same format and contain the following major components:</p>
<p><code>tblspace tblspace 是描述特定 dbspace 中所有 tblspace 的位置和结构的页面集合。tblspace tblspace 中的大多数页面格式相同，并包含以下主要组件：</code></p>
<p><strong>•</strong> The number and location of extents</p>
<p><code>extent的数量和位置</code></p>
<p><strong>•</strong> Information about special columns (large objects and VARCHAR data)</p>
<p><code>有关特殊列（大对象和 VARCHAR 数据）的信息</code></p>
<p><strong>•</strong> An array of index key information</p>
<p><code>索引键信息数组</code></p>
<p><strong>•</strong> The database and table name</p>
<p><code>数据库和表名</code></p>
<p>You can find out where the tblspace tblspace extents are located by running <strong>oncheck -pe</strong> and looking for <strong>dbspace_name:’informix’.TBLSpace</strong>.</p>
<p><code>运行oncheck -pe并查找dbspace_name:&#39;gbasedbt&#39;.TBLSpace，即可找出 tblspace tblspace extents 的位置。</code></p>
<p>实测，oncheck -pe出来一大堆信息，看不懂，截选部分，rootdbs:’gbasedbt’.TBLSpace 有好几个，下边还有。再下边还有其他dbspace的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">DBspace Usage Report: rootdbs             Owner: gbasedbt  Created: 04/17/2025</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chunk Pathname                             Pagesize(k)  Size(p)  Used(p)  Free(p)</span><br><span class="line">     1 /opt/gbase/storage/rootdbs                     2    78848    13748    65100</span><br><span class="line"></span><br><span class="line"> Description                                                   Offset(p)  Size(p)</span><br><span class="line"> ------------------------------------------------------------- -------- --------</span><br><span class="line"> RESERVED PAGES                                                       0       12</span><br><span class="line"> CHUNK FREELIST PAGE                                                 12        1</span><br><span class="line"> rootdbs:<span class="string">&#x27;gbasedbt&#x27;</span>.TBLSpace                                         13      250</span><br><span class="line"> sysadmin:<span class="string">&#x27;gbasedbt&#x27;</span>.ix_ph_run_03                                   263        4</span><br><span class="line"> tmpsbspace:<span class="string">&#x27;gbasedbt&#x27;</span>.tmpsbspace_desc                              267        4</span><br><span class="line"> RESERVED PAGES                                                     271        2</span><br><span class="line"> RESERVED PAGES                                                     273        2</span><br><span class="line"> sysadmin:<span class="string">&#x27;gbasedbt&#x27;</span>.command_history                                275        8</span><br><span class="line"> sysadmin:<span class="string">&#x27;gbasedbt&#x27;</span>.ix_cmd_hist_02                                 283        4</span><br><span class="line"> sysadmin:<span class="string">&#x27;gbasedbt&#x27;</span>.mon_iohist                                     287        8</span><br><span class="line"> sysadmin:<span class="string">&#x27;gbasedbt&#x27;</span>.mon_config                                     295        8</span><br><span class="line"> sysadmin:<span class="string">&#x27;gbasedbt&#x27;</span>.mon_page_usage                                 303        8</span><br><span class="line"> sysadmin:<span class="string">&#x27;gbasedbt&#x27;</span>.mon_page_usage_ix1                             311        4</span><br><span class="line"> sysadmin:<span class="string">&#x27;gbasedbt&#x27;</span>.mon_page_usage_ix2                             315        4</span><br><span class="line"> sysadmin:<span class="string">&#x27;gbasedbt&#x27;</span>.mon_page_usage_ix1                             319        4</span><br><span class="line"> sysadmin:<span class="string">&#x27;gbasedbt&#x27;</span>.mon_page_usage                                 323        8</span><br><span class="line"> sysadmin:<span class="string">&#x27;gbasedbt&#x27;</span>.mon_page_usage_ix2                             331        4</span><br><span class="line"> sysadmin:<span class="string">&#x27;gbasedbt&#x27;</span>.mon_users                                      335        8</span><br><span class="line"> sysadmin:<span class="string">&#x27;gbasedbt&#x27;</span>.mon_table_profile                              343       16</span><br><span class="line"> sysadmin:<span class="string">&#x27;gbasedbt&#x27;</span>.mon_checkpoint                                 359        8</span><br><span class="line"> rootdbs:<span class="string">&#x27;gbasedbt&#x27;</span>.TBLSpace                                        367      200</span><br><span class="line"> sysadmin:<span class="string">&#x27;gbasedbt&#x27;</span>.idx_mon_ckpt_1                                 567        4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Database tblspace</strong></p>
<p>The database tblspace is a list of all databases in the Informix Dynamic Server system, and includes the following components:</p>
<p><code>database tblspace 是 IDS 系统中所有数据库的列表，包括以下组件：</code></p>
<p><strong>•</strong> Database name</p>
<p><code>数据库名</code></p>
<p><strong>•</strong> Database owner</p>
<p><code>数据库所有者</code></p>
<p><strong>•</strong> Date and time the database was created</p>
<p><code>创建数据库的日期和时间</code></p>
<p><strong>•</strong> The partition number of the <strong>systables</strong> system catalog table for this database</p>
<p><code>该数据库的 systables 系统表的 partition number</code></p>
<p><strong>•</strong> Flags that show the logging mode for the database</p>
<p><code>显示数据库日志记录模式的标志</code></p>
<p>To find out where the database tblspace is physically located on your server, use the <strong>oncheck -pe</strong> command to generate an extent report and look for the extents allocated to <strong>sysmaster:’informix’.sysdatabases</strong>.</p>
<p><code>要找出数据库 tblspace 在服务器上的物理位置，请使用 oncheck -pe 命令生成一份扩展报告，并查找分配给 sysmaster:&#39;gbasedbt&#39;.sysdatabases 的extents。</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysmaster:<span class="string">&#x27;gbasedbt&#x27;</span>.sysdatabases                                27447        4</span><br></pre></td></tr></table></figure>

<p>紫本180页：</p>
<p>6.4.2.2 tablespace</p>
<blockquote>
<p>​		tablespace 是一个逻辑概念，指一个表或者索引所占用的空间。GBase 8t 用 tablespace 来描述一个表或者索引信息。一个 tablespace 是多个 extent 的逻辑集合，可以分布在不同的 dbspace 或者 chunk 上。在 GBase 8t 系统表中对表、索引采用 tablespace 进行描述。</p>
<p>​		GBase 8t把分片表、索引的一个分片作为一个tablespace进行管理。每个表、索引在GBase8t 内部都有一个 partnum，在 GBase 8t 内部以该编号进行管理。例如在一个 GBase 8t 实例下有一个 database tblspace，包含所有的数据库 databases 的信息。database tblspace 的 partnum永远是 x00100002，位于 root dbspaces 上，也就是 sysmaster 数据中的 sysdatabases 表。</p>
<p>​		我们可以通过查询 sysmaster 的 systabnames 表得到一个数据库实例下的所有表、索引的 tblspace 信息。</p>
</blockquote>
<p>所以，database tblspace有系统表对应sysdatabases，而Tblspace tblspace看着应该是同样有个系统表，叫做Tblspace（描述特定 dbspace 中所有 tblspace），但又不知道在哪</p>
<p><a target="_blank" rel="noopener" href="https://www.ibm.com/support/pages/what-tblspace-tblspace">What is TBLspace TBLspace?</a></p>
<p>这篇文章提到：You are running IBM® Informix® Dynamic Server (IDS) database server and create a regular Dbspace. This Dbspace contains an internal table called TBLspace TBLspace. You cannot access the table using SQL commands.</p>
<p>所以，有个内部表叫做TBLspace TBLspace，无法用SQL访问</p>
<p>deepseek：</p>
<ul>
<li>它是Informix内核管理的<strong>元数据表</strong>（metadata table）</li>
<li><strong>不开放SQL访问</strong>（如文档所述：*”You cannot access the table using SQL commands”*）</li>
<li>仅通过底层存储引擎直接管理</li>
</ul>
<p><strong>Layout of a Non-Root Chunk</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505101345909.png" alt="image-20250510134500787"></p>
<p><strong>Notes:</strong></p>
<p>The above slide shows the layout of all other chunks in the system except the root chunk. There are two slightly different types: those that are the first chunks in their respective dbspaces, and those that are subsequent to the first chunk.</p>
<p><code>上面的幻灯片显示了系统中除root chunk之外的所有其他chunk的布局。有两种略有不同的类型：一种是各自dbspace中的第一个chunk，另一种是第一个chunk之后的chunk。</code></p>
<p>第一个chunk就是后边提到的所谓<strong>Primary Chunk</strong></p>
<p><strong>Reserved pages</strong></p>
<p>The first two pages of any non-root chunk are reserved for nothing. They are not even initialized with a page header. The early Informix Dynamic Server designers thought they might need them someday, but so far, the most sensible suggested uses have been for <em>binary graffiti</em> and <em>credits</em>.</p>
<p><code>在任何非根区块（non-root chunk）中，前两页是保留不用的。它们甚至没有被初始化为页面头（page header）。早期的 IDS 设计者认为将来可能会用到它们，但到目前为止，最合理的建议用途是用于“二进制涂鸦”（binary graffiti）和“致谢名单”（credits）。</code></p>
<p><strong>Chunk free list</strong></p>
<p>In every chunk, the page following the reserved pages is a chunk free-list page.</p>
<p><code>在每个chunk中，紧跟在保留页之后的那一页是chunk的空闲页列表页（chunk free-list page）。</code></p>
<p><strong>Tblspace tblspace</strong></p>
<p>Every dbspace contains a tblspace tblspace, also called a partition table. The first extent of the tblspace tblspace is always allocated in the first chunk of the dbspace. Like any other tblspace, when additional extents are required, they are allocated wherever there is room in the dbspace.</p>
<p><code>每个 dbspace 都包含一个 tblspace tblspace，也称为分区表(partition table)。tblspace tblspace 的第一个 extent 总是分配在 dbspace 的第一个chunk中。与其他 tblspace 一样，当需要额外的扩展时，它们会被分配到 dbspace 中有空间的地方。</code></p>
<p>The initial and subsequent extent size for the partition table in non-root dbspaces is 50 pages.</p>
<p><code>非root dbspace中分区表（partition table）的初始和后续extent大小为 50 页。</code></p>
<p><strong>Overview of Root Reserved Pages</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505101359231.png" alt="image-20250510135946163"></p>
<p><strong>Notes:</strong></p>
<p>The first 12 pages of the root chunk are reserved for system information. Starting with page 2, the pages are grouped in pairs and are alternately updated.</p>
<p><code>root chunk的前 12 页保留给系统信息。从第 2 页开始，页面成对分组，交替更新。</code></p>
<p><strong>Page zero</strong></p>
<p>Page 0 contains the Informix copyright and version information, the minimum page size, and the date and time of the system’s creation.</p>
<p><code>第 0 页包含 Informix 版权和版本信息、最小页面大小以及系统创建的日期和时间。</code></p>
<p><strong>Configuration page</strong></p>
<p>Page 1 contains a copy of all the information stored in the system’s configuration file (<strong>$INFORMIXDIR&#x2F;etc&#x2F;$ONCONFIG</strong>) at the time the server was last brought online.</p>
<p><code>第 1 页包含服务器上次联机时存储在系统配置文件（$INFORMIXDIR/etc/$ONCONFIG）中的所有信息的副本。</code></p>
<p><strong>Checkpoint&#x2F;logical log pages</strong></p>
<p>Page 2 and page 3 are the checkpoint&#x2F;logical log pages. The current checkpoint&#x2F;logical log page gives the location, date and time of the last checkpoint, and the location and current status of each of the logical logs.</p>
<p><code>第 2 页和第 3 页是检查点/逻辑日志页面。当前检查点/逻辑日志页面显示上次检查点的位置、日期和时间，以及每个逻辑日志的位置和当前状态。</code></p>
<p><strong>Dbspace pages</strong></p>
<p>Page 4 and page 5 are the dbspace pages. Each entry on the current dbspace page tracks the status, location, data, and creation time of a dbspace.</p>
<p><code>第 4 页和第 5 页是 dbspace 页面。当前dbspace页面的每个条目都会跟踪 dbspace 的状态、位置、数据和创建时间。</code></p>
<p><strong>Primary chunk pages</strong></p>
<p>Pages 6 and 7 are the reserved pages that contain information about each of the primary chunks on the server. For each chunk, the current primary-chunk page contains information about the pathname, size, offset, and status of the chunk.</p>
<p><code>第 6 页和第 7 页是保留页，包含server上每个primary chunk的信息。对于每个chunk，当前的primary chunk page包含该chunk的路径名、大小、偏移量和状态信息。</code></p>
<p><strong>Mirror chunk pages</strong></p>
<p>Pages 8 and 9 are the mirror chunk pages. The structure of these pages are the same as the primary chunk pages</p>
<p><code>第 8 页和第 9 页是mirror chunk页面。这些页面的结构与primary chunk pages相同</code></p>
<p><strong>Archive pages</strong></p>
<p>Pages 10 and 11 (0xa and 0xb) are the archive pages. These pages contains information on the most recent archives performed on the server.</p>
<p><code>第 10 页和第 11 页（0xa 和 0xb）是存档页面。这些页面包含在服务器上进行的最新存档信息。</code></p>
<p><strong>The Copyright Page</strong></p>
<p>oncheck -pr，下边还有很多内容，与本节无关，不贴出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Validating GBase Database Server reserved pages</span><br><span class="line"></span><br><span class="line">    Validating PAGE_PZERO...</span><br><span class="line"></span><br><span class="line">    Identity                       GBase Database Server Co</span><br><span class="line">                                   pyright 2001, 2021  Gene</span><br><span class="line">                                   ral Data Corporation</span><br><span class="line">    Database system state          0</span><br><span class="line">    Database system flags          0x3</span><br><span class="line">    Page Size                      2048 (b)</span><br><span class="line">    Date/Time created              04/17/2025 08:44:48</span><br><span class="line">    Version number of creator      32</span><br><span class="line">    Last modified time stamp       0</span><br><span class="line">    UID of rootdbs creator         1001</span><br><span class="line">    Index Page Logging             OFF</span><br><span class="line">    HA Disk Owner                  &lt;null&gt;</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure>

<p><strong>Notes:</strong></p>
<p>The slide above shows a sample <strong>oncheck -pr</strong> output for the copyright page. </p>
<p><code>上面的幻灯片展示了版权页的oncheck -pr输出示例。</code></p>
<p>One important use of this page is the identification of the version of the Informix Dynamic Server system. The current version is listed here under <strong>Version number of creator</strong>. If the version number is earlier than the <strong>oninit</strong> version, the database server performs any upgrade steps required to move the Informix Dynamic Server system to the new version. </p>
<p><code>本页的一个重要用途是识别 IDS 系统的版本。当前版本列于此处的 Version number of creator 下。如果版本号早于 oninit 版本， database server 将执行所有必要的升级步骤，以将 Informix Dynamic Server 系统迁移到新版本。</code></p>
<p>Upgrading the server is not always required; it is only necessary when the disk architecture or the structure of tables in <strong>sysmaster</strong> or <strong>sysutils</strong> has changed.</p>
<p><code>并不总是需要升级 server；只有在磁盘架构或 sysmaster 或 sysutils 中的表格结构发生变化时才需要升级。</code></p>
<p><strong>Hint</strong></p>
<p>Run the command:</p>
<p>​		oncheck -pP 1 0</p>
<p>and compare that output to the report generated by <strong>oncheck -pr</strong>.</p>
<p>1001 -&gt; 3e9    20 - &gt; 32</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@frh gbase]<span class="comment"># oncheck -pP 1 0</span></span><br><span class="line">addr             stamp    chksum nslots flag <span class="built_in">type</span>         frptr frcnt next     prev</span><br><span class="line">1:0              157435   66f8   3      1800 ROOTRSV      304   1728  0        0</span><br><span class="line">        slot ptr   len   flg</span><br><span class="line">        1    24    252   0</span><br><span class="line">        3    276   28    0</span><br><span class="line">slot   1:</span><br><span class="line">    0: 47 42 61 73 65 20 44 61 74 61 62 61 73 65 20 53   GBase Database S</span><br><span class="line">   16: 65 72 76 65 72 20 43 6f 70 79 72 69 67 68 74 20   erver Copyright</span><br><span class="line">   32: 32 30 30 31 2c 20 32 30 32 31 20 20 47 65 6e 65   2001, 2021  Gene</span><br><span class="line">   48: 72 61 6c 20 44 61 74 61 20 43 6f 72 70 6f 72 61   ral Data Corpora</span><br><span class="line">   64: 74 69 6f 6e  0  0  0  0  0  0  0  0  0  0  0  0   tion............</span><br><span class="line">   80:  0  0  3  0  0  8  0  0 f0 21  1 68 20  0  0  0   ........p!.h ...</span><br><span class="line">   96:  0  0  0  0 e9  3  0  0 31 32 31 34  1  0  0  0   ....i...1214....</span><br><span class="line">  112:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0   ................</span><br><span class="line">  128:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0   ................</span><br><span class="line">  144:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0   ................</span><br><span class="line">  160:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0   ................</span><br><span class="line">  176:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0   ................</span><br><span class="line">  192:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0   ................</span><br><span class="line">  208:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0   ................</span><br><span class="line">  224:  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0   ................</span><br><span class="line">  240:  0  0  0  0  0  0  0  0  0  0  0  0               ................</span><br><span class="line">slot   3:</span><br><span class="line">    0:  3  0 10  0 3b 6b  0  0  1  0  0  0  0  0  0  0   ....;k..........</span><br><span class="line">   16:  c 46 22 30 34 2d 32 30 32 35  0  0               .F<span class="string">&quot;04-2025......</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>



<p><strong>The Configuration Page</strong></p>
<p>oncheck -pr截取</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    Validating PAGE_CONFIG...</span><br><span class="line"></span><br><span class="line">    ROOTNAME                       rootdbs</span><br><span class="line">    ROOTPATH                       /opt/gbase/storage/rootdbs</span><br><span class="line">    ROOTOFFSET                     0 (k)</span><br><span class="line">    ROOTSIZE                       157696 (k)</span><br><span class="line">    MIRROR                         0</span><br><span class="line">    MIRRORPATH                     /opt/gbase/tmp/demo_on.root_mirror</span><br><span class="line">    MIRROROFFSET                   0 (k)</span><br><span class="line">    DBSERVERNAME                   ol_gbasedbt1210_1</span><br><span class="line">    SERVERNUM                      0</span><br><span class="line">    MSGPATH                        /opt/gbase/ol_gbasedbt1210_1.<span class="built_in">log</span></span><br><span class="line">    TAPEDEV                        /dev/tapedev</span><br><span class="line">    TAPESIZE                       0 (k)</span><br><span class="line">    TAPEBLK                        32 (k)</span><br><span class="line">    LTAPEDEV                       /dev/null</span><br><span class="line">    LTAPESIZE                      0 (k)</span><br><span class="line">    LTAPEBLK                       32 (k)</span><br><span class="line">    PHYSFILE                       71972 (k)</span><br><span class="line">    PHYSBUFF                       512 (k)</span><br><span class="line">    LOGFILES                       19</span><br><span class="line">    LOGSIZE                        6144 (k)</span><br><span class="line">    LOGBUFF                        256 (k)</span><br><span class="line">    DYNAMIC_LOGS                   2</span><br><span class="line">    LTXHWM                         70 (%)</span><br><span class="line">    LTXEHWM                        80 (%)</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p><strong>Notes:</strong></p>
<p>The configuration page contains values for all <em>documented</em> parameters in the configuration file ($ONCONFIG). In other words, it is not simply a copy of whatever happens to be in the configuration file; adding additional parameters to the configuration file does not add anything new to the configuration page.</p>
<p><code>configuration page 包含配置文件 ($ONCONFIG) 中所有已记录参数的值。换句话说，它并非配置文件中内容的简单复制；在配置文件中添加其他参数并不会给 configuration page 添加任何新内容。</code></p>
<p><strong>Seen and unseen</strong></p>
<p>The <strong>oncheck -pr</strong> output above shows an example of the contents of the configuration page. Note that on some platforms, many legitimate parameters in the configuration file do not show up in this report, such as NUMCPUVPS, STACKSIZE, and SHMTOTAL.</p>
<p><code>上面的 oncheck -pr 输出显示了 configuration page 内容的示例。请注意，在某些平台上，configuration page 中的许多合法参数不会显示在此报告中，例如 NUMCPUVPS、STACKSIZE 和 SHMTOTAL。</code></p>
<blockquote>
<p>legitimate 合法的 英[lɪˈdʒɪtɪmət]美[lɪˈdʒɪtɪmət]</p>
</blockquote>
<p>The <strong>onstat -c</strong> command does not use the information from these pages. This command reads the configuration file instead of the reserved page.</p>
<p><code>onstat -c 命令不使用这些页面中的信息。此命令读取配置文件，而不是保留页。</code></p>
<p><strong>Hint</strong></p>
<p>Run the command:</p>
<p>​		oncheck -pP 1 1</p>
<p>and compare that output to the report generated by <strong>oncheck -pr</strong>. Notice that <strong>oncheck -pP</strong>, being a more general page-displaying tool, reveals parameters on the configuration page not displayed by <strong>oncheck -pr</strong>.</p>
<p><code>请注意，oncheck -pP 是一个更通用的页面显示工具，它会显示 oncheck -pr 未显示的配置页面上的参数。</code></p>
<blockquote>
<p>reveals<br>英[rɪˈviːlz] 美[rɪˈviːlz]<br>v.揭示;显示;透露;展示;露出;显出;<br>n.揭示（reveal 的复数）;</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">slot   1:</span><br><span class="line">    0: 52 4f 4f 54 4e 41 4d 45 20 72 6f 6f 74 64 62 73   ROOTNAME rootdbs</span><br><span class="line">   16:  0                                                ................</span><br><span class="line">slot   2:</span><br><span class="line">    0: 52 4f 4f 54 50 41 54 48 20 2f 6f 70 74 2f 67 62   ROOTPATH /opt/gb</span><br><span class="line">   16: 61 73 65 2f 73 74 6f 72 61 67 65 2f 72 6f 6f 74   ase/storage/root</span><br><span class="line">   32: 64 62 73  0                                       dbs.............</span><br><span class="line">slot   3:</span><br><span class="line">    0: 52 4f 4f 54 4f 46 46 53 45 54 20 30  0            ROOTOFFSET 0....</span><br><span class="line">slot   4:</span><br><span class="line">    0: 52 4f 4f 54 53 49 5a 45 20 31 35 37 36 39 36  0   ROOTSIZE 157696.</span><br><span class="line">slot   5:</span><br><span class="line">    0: 4d 49 52 52 4f 52 20 30  0                        MIRROR 0........</span><br></pre></td></tr></table></figure>

<p>上面是 oncheck -pP 1 1 截取部分</p>
<p><strong>The Checkpoint&#x2F;Logical Log Page</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Validating PAGE_1CKPT &amp; PAGE_2CKPT...</span><br><span class="line">      Using check point page PAGE_2CKPT.</span><br><span class="line"></span><br><span class="line">Time stamp of checkpoint       0x7f7e6b</span><br><span class="line">Time of checkpoint             05/10/2025 05:17:37</span><br><span class="line">Physical <span class="built_in">log</span> begin address     2:53</span><br><span class="line">Physical <span class="built_in">log</span> size              35986 (p)</span><br><span class="line">Physical <span class="built_in">log</span> position at Ckpt  30148</span><br><span class="line">Logical <span class="built_in">log</span> unique identifier  148</span><br><span class="line">Logical <span class="built_in">log</span> position at Ckpt   0xc510c0 (Page 3153, byte 192)</span><br><span class="line">Checkpoint Interval            98</span><br><span class="line">DBspace descriptor page        1:4</span><br><span class="line">Chunk descriptor page          1:7</span><br><span class="line">Mirror chunk descriptor page   1:8</span><br><span class="line"></span><br><span class="line">Log file number                14</span><br><span class="line">Unique identifier              146</span><br><span class="line">Log file flags                 0x5        Log file <span class="keyword">in</span> use</span><br><span class="line">&amp;                                         Log file has been backed up</span><br><span class="line">Physical location              3:29483</span><br><span class="line">Log size                       3270 (p)</span><br><span class="line">Number pages used              3270</span><br><span class="line">Date/Time file filled          04/17/2025 09:10:15</span><br><span class="line">Time stamp                     0x578dde</span><br><span class="line"><span class="comment"># 下边把剩余的所有 Log file number 都列出来了</span></span><br></pre></td></tr></table></figure>

<p><strong>Notes:</strong></p>
<p>The current checkpoint&#x2F;logical log page gives the location, date, and time of the last checkpoint, and the location and current status of the logical logs.</p>
<p><code>当前 checkpoint/logical log page 给出了最后一个检查点的位置、日期和时间，以及逻辑日志的位置和当前状态。</code></p>
<p>Beginning with page 2, the reserved pages are paired. However, only one page out of the pair is current. So when we refer to the primary chunk reserved page, dbspace reserved page, or the checkpoint&#x2F;logical log reserved page, we are talking about the current page of the pair. The current page can be easily found by comparing the timestamps, which is the method used by <strong>oncheck -pr</strong> when deciding which of the pages to display. Notice that at the top of each reserved page output, <strong>oncheck</strong> indicates which page of the pair it has chosen to display.</p>
<p><code>从第 2 页开始，保留页是成对的。但是，每对页中只有一个是当前页。因此，当我们提到 primary chunk 保留页、dbspace 保留页或检查点/逻辑日志保留页时，我们指的是该对中的当前页。可以通过比较时间戳轻松找到当前页，这也是 oncheck -pr 在决定显示哪些页时使用的方法。请注意，在每个保留页输出的顶部，oncheck 都会指示它选择显示的页对中的哪个页。（说的应该是“Using check point page PAGE_2CKPT.”）</code></p>
<p><strong>Hint</strong></p>
<p>Run the commands:</p>
<p>​		oncheck -pP 1 2</p>
<p>and</p>
<p>​		oncheck -pP 1 3</p>
<p>First, determine which of the pages is more current by looking at the timestamps. Then compare your observation with the <strong>oncheck -pr</strong> report.</p>
<p>可能意思是看2和3，哪个stamp数字更大吧</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">oncheck -pP 1 2</span><br><span class="line"></span><br><span class="line">addr             stamp    chksum nslots flag <span class="built_in">type</span>         frptr frcnt next     prev</span><br><span class="line">1:2              8343790  5092   20     1800 ROOTRSV      680   1284  0        0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">oncheck -pP 1 3</span><br><span class="line"></span><br><span class="line">addr             stamp    chksum nslots flag <span class="built_in">type</span>         frptr frcnt next     prev</span><br><span class="line">1:3              8355443  7e0e   20     1800 ROOTRSV      680   1284  0        0</span><br></pre></td></tr></table></figure>



<p><strong>A pair of nearly identical pages</strong></p>
<p>You might still be confused about how the two checkpoint&#x2F;logical log pages are split. It is <strong>not</strong> the case that one page contains checkpoint information while the other page contains logical log information. There is checkpoint and logical log information on both pages, as shown here:</p>
<p><code>您可能仍然对两个 checkpoint/logical log page 的划分方式感到困惑。一个页面包含检查点信息，而另一个页面包含逻辑日志信息，这种情况并非如此。两个页面上都包含检查点和逻辑日志信息，如下所示：</code></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505102139970.png" alt="image-20250510213923811"></p>
<p>The difference between the two pages is that one contains up-to-date information, and the other contains information that is one iteration out of date. This is true for all the reserved-page pairs.</p>
<p><code>这两个页面的区别在于，一个页面包含最新信息，而另一个页面包含的信息已经过期一个迭代。所有保留页对都是如此。</code></p>
<p>图上，黑横线是page分割线，黑线下边紧邻是页头，上边紧邻右侧是页尾</p>
<p><strong>The checkpoint structure vs. checkpoint records</strong></p>
<p>It is important to distinguish between the checkpoint <em>structure</em>, found on the checkpoint&#x2F;logical log page, and checkpoint <em>records</em>.</p>
<p><code>必须区分检查点/逻辑日志页面上的 checkpoint structure 和 checkpoint records。</code></p>
<p>Checkpoint records are written to the logical logs. One of the last steps taken by IDS during a checkpoint is to write a checkpoint record to the current logical log file.</p>
<p><code>Checkpoint records 写入逻辑日志。在检查点过程中，IDS 采取的最后一个步骤是向当前逻辑日志文件写入检查点记录。</code></p>
<p>At any given time, there can be many checkpoint records scattered throughout the logical logs on disk. But of those records, only the most recently written record is important to fast recovery. The checkpoint structure*,* on the checkpoint&#x2F;logical log page, contains information that, in the event of a system shutdown or crash, guides fast recovery to this most-important, most-recent checkpoint record.</p>
<p><code>在任意时刻，磁盘上的逻辑日志中可能分布着许多检查点（checkpoint）记录。但在这些记录中，只有最近写入的那条记录对快速恢复最为关键。位于检查点/逻辑日志页上的检查点结构（checkpoint structure）包含了相关信息，在系统关闭或崩溃的情况下，这些信息会引导快速恢复过程定位到这一条最重要、最新的检查点记录。。</code></p>
<blockquote>
<p>scatter 分散 英[ˈskætə(r)] 美[ˈskætər]</p>
<p>throughout 遍及 英[θruːˈaʊt] 美[θruːˈaʊt]</p>
</blockquote>
<p><strong>The Checkpoint Structure</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Validating PAGE_1CKPT &amp; PAGE_2CKPT...</span><br><span class="line">      Using check point page PAGE_2CKPT.</span><br><span class="line"></span><br><span class="line">Time stamp of checkpoint       0x7f7e6b</span><br><span class="line">Time of checkpoint             05/10/2025 05:17:37</span><br><span class="line">Physical <span class="built_in">log</span> begin address     2:53</span><br><span class="line">Physical <span class="built_in">log</span> size              35986 (p)</span><br><span class="line">Physical <span class="built_in">log</span> position at Ckpt  30148</span><br><span class="line">Logical <span class="built_in">log</span> unique identifier  148</span><br><span class="line">Logical <span class="built_in">log</span> position at Ckpt   0xc510c0 (Page 3153, byte 192)</span><br><span class="line">Checkpoint Interval            98</span><br><span class="line">DBspace descriptor page        1:4</span><br><span class="line">Chunk descriptor page          1:7</span><br><span class="line">Mirror chunk descriptor page   1:8</span><br></pre></td></tr></table></figure>

<p><strong>Notes:</strong></p>
<p>What follows is an item-by-item analysis of the checkpoint structure information displayed by <strong>oncheck -pr</strong>. Indicated along with an explanation of each element is its notation (hex or decimal).</p>
<p><code>下面逐项分析 oncheck -pr 显示的检查点结构信息。每个元素的表示方式（十六进制或十进制）也会一并标出，并附带解释。</code></p>
<p><strong>Time stamp of checkpoint</strong> (hex) – The global system timestamp that is current during the last moments of the checkpoint. Notice that the timestamp on the current checkpoint&#x2F;logical log page is often just one or two ticks higher than the timestamp value stored in the checkpoint structure.</p>
<p><code>检查点最后时刻的全局系统时间戳。请注意，当前 checkpoint/logical log page 上的时间戳往往只比存储在 checkpoint structure 中的时间戳值高一两个刻度。</code></p>
<p>checkpoint&#x2F;logical log page 上的时间戳，指的是页尾的时间戳吧，也就是 oncheck -pP 1 3 的 stamp 值 8355443（0x7F7E73），比0x7f7e6b大一点。</p>
<p><strong>Time of checkpoint</strong> – The true date and time of the last checkpoint, based on the UNIX host’s <strong>localtime</strong> function.</p>
<p><code>上次检查点的真实日期和时间，基于 UNIX 主机的 localtime 函数。</code></p>
<p><strong>Physical log begin address</strong> (decimal:decimal) – This is the location (chunk number and page offset) of the first page in the physical log. You can verify this information using <strong>oncheck -pe</strong>.</p>
<p><code>这是物理日志中第一页的位置（chunk编号和页偏移量）。您可以使用 oncheck -pe 验证此信息。</code></p>
<p>oncheck -pe截选，可以看到，chunk 2，offset 53</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DBspace Usage Report: plog                Owner: gbasedbt  Created: 04/17/2025</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chunk Pathname                             Pagesize(k)  Size(p)  Used(p)  Free(p)</span><br><span class="line">     2 /opt/gbase/storage/ol_gbasedbt1210_1_plog_p_1            2    36045    36039        6</span><br><span class="line"></span><br><span class="line"> Description                                                   Offset(p)  Size(p)</span><br><span class="line"> ------------------------------------------------------------- -------- --------</span><br><span class="line"> RESERVED PAGES                                                       0        2</span><br><span class="line"> CHUNK FREELIST PAGE                                                  2        1</span><br><span class="line"> plog:<span class="string">&#x27;gbasedbt&#x27;</span>.TBLSpace                                             3       50</span><br><span class="line"> PHYSICAL LOG                                                        53    35986</span><br><span class="line"> FREE                                                             36039        6</span><br><span class="line"></span><br><span class="line"> Total Used:    36039</span><br><span class="line"> Total Free:        6</span><br></pre></td></tr></table></figure>

<p><strong>Physical log size</strong> (decimal) – The size, in pages, of the physical log.</p>
<p><code>物理日志的大小（以页为单位）。</code></p>
<p><strong>Physical log position at Ckpt</strong> (decimal) – This is the page offset within the physical log that was current at the time of the last checkpoint, expressed as a number of pages offset from the physical log begin address. The first phase of fast recovery, physical recovery, starts with the page following the one indicated here.</p>
<p><code>这是上一次检查点时物理日志中的页面偏移量，表示为从物理日志起始地址偏移的页数。快速恢复的第一阶段，即物理恢复，从此处所示页面之后的页面开始。</code></p>
<p><strong>Logical log unique identifier</strong> (decimal) – This is the unique ID of the logical log that contains the most recently written checkpoint record.</p>
<p><code>这是包含最近写入的 checkpoint record 的逻辑日志的唯一 ID。</code></p>
<p><strong>Logical log position at Ckpt</strong> (hex) – This is the position within the logical log indicated by the previous element in the checkpoint structure (logical log unique identifier) where the most-recently-written checkpoint record can actually be found. This is also known as the <em>logpos</em>.</p>
<p><code>这是 checkpoint structure 中前一个元素 logical log unique identifier(就上边那个) 所指示的逻辑日志中的位置，在该位置可实际找到最近写入的 checkpoint record。这也称为 logpos。</code></p>
<p><strong>Dbspace descriptor page</strong> (decimal:decimal) – This is the location (chunk number and offset) of the dbspace reserved page that was current at the time of the checkpoint. Of course, the timestamps on the two dbspace pages could also be compared to determine which one was more up-to-date.</p>
<p><code>这是检查点时最新的 dbspace 保留页面的位置（chunk编号和偏移量）。当然，也可以通过比较两个 dbspace 页面上的时间戳来确定哪个页面更新。</code></p>
<p><strong>Chunk descriptor page</strong> (decimal:decimal) – This is the location (chunk number and offset) of the primary chunk reserved page that was current at the time of the last checkpoint. The same redundancy involved with the previous element of the checkpoint structure applies to this one.</p>
<p><code>这是上次检查点时当前的 primary chunk 保留页的位置（chunk编号和偏移量）。检查点结构的前一个元素所涉及的冗余同样适用于这个元素。</code></p>
<blockquote>
<p>redundancy 冗余 英[rɪˈdʌndənsi] 美[rɪˈdʌndənsi]</p>
</blockquote>
<p><strong>Mirror chunk descriptor page</strong> (decimal:decimal) – This is the location (chunk number and offset) of the mirror chunk reserved page that current at the time of the last checkpoint.</p>
<p><code>这是上次检查点时当前 mirror chunk 保留页的位置（chunk编号和偏移量）。</code></p>
<p><strong>The Logical Log File Structure</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">Log file number                14</span><br><span class="line">   Unique identifier              146</span><br><span class="line">   Log file flags                 0x5        Log file <span class="keyword">in</span> use</span><br><span class="line">   &amp;                                         Log file has been backed up</span><br><span class="line">   Physical location              3:29483</span><br><span class="line">   Log size                       3270 (p)</span><br><span class="line">   Number pages used              3270</span><br><span class="line">   Date/Time file filled          04/17/2025 09:10:15</span><br><span class="line">   Time stamp                     0x578dde</span><br></pre></td></tr></table></figure>

<p><strong>Notes:</strong></p>
<p>For every logical log file defined in the system, there is one log file structure in the checkpoint&#x2F;logical log reserved page.</p>
<p><code>对于系统中定义的每个逻辑日志文件，在 checkpoint/logical log 预留页面中有一个日志文件结构。</code></p>
<p>注意，这是最后一次检查点时的逻辑日志文件结构，不是当前的，onstat -l 时，flags 对不上的</p>
<p><strong>Log file number</strong> (decimal) – The number of the log file in the Informix Dynamic Server system. Logical log files are generally used in the order of their log file number.</p>
<p><code>IDS 系统中日志文件的编号。逻辑日志文件通常按其日志文件编号的顺序使用。</code></p>
<p><strong>Unique identifier</strong> (decimal) – This integer is always associated with the particular set of logical log records currently stored in this log file. A zero value means the log file is free.</p>
<p><code>该整数总是与当前存储在该日志文件中的特定逻辑日志记录集合相关联。零值表示日志文件空闲。</code></p>
<p>看不懂说的什么，onstat -l 可以看到这两个数，在同一行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@frh gbase]<span class="comment"># onstat -l</span></span><br><span class="line">……</span><br><span class="line">address          number   flags    uniqid   begin                size     used    %used</span><br><span class="line">4559fa60         14       U-B----  146      3:29483              3270     3270   100.00</span><br><span class="line">4559fac8         13       U-B----  147      3:26213              3270     3270   100.00</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p><strong>Log containing last checkpoint</strong> (decimal) – This indicates the logical log page number and byte offset into that log where the last checkpoint record was recorded.</p>
<p><code>这表示记录最后一次检查点记录的逻辑日志页码和字节偏移量。</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Log file number                10</span><br><span class="line">Unique identifier              150</span><br><span class="line">Log contains last checkpoint:  Page 1260, byte 192</span><br><span class="line">Log file flags                 0x3        Log file <span class="keyword">in</span> use</span><br><span class="line">&amp;                                         Current <span class="built_in">log</span> file</span><br><span class="line">Physical location              3:16403</span><br><span class="line">Log size                       3270 (p)</span><br><span class="line">Number pages used              1261</span><br><span class="line">Date/Time file filled          04/17/2025 09:12:24</span><br><span class="line">Time stamp                     0x6171d2</span><br><span class="line"></span><br><span class="line">address          number   flags    uniqid   begin                size     used    %used</span><br><span class="line">4559fa60         14       U-B----  146      3:29483              3270     3270   100.00</span><br><span class="line">4559fac8         13       U-B----  147      3:26213              3270     3270   100.00</span><br><span class="line">4559fb30         12       U-B----  148      3:22943              3270     3270   100.00</span><br><span class="line">4559fb98         11       U-B----  149      3:19673              3270     3270   100.00</span><br><span class="line">4559fc00         10       U-B---L  150      3:16403              3270     3270   100.00</span><br><span class="line">4559fc68         9        U-B----  151      3:13133              3270     3270   100.00</span><br></pre></td></tr></table></figure>

<p>必须有L的逻辑日志文件，才有 Log contains last checkpoint</p>
<p><strong>Log file flags</strong> (hex) – With the miracle of the logical OR, up to five different logical log flags, like the page flags described in the previous chapter, can be packed into this one short integer. The individual flag values are:</p>
<p><code>利用逻辑或的神奇功能，可以将最多五个不同的逻辑日志标志（如上一章所述的页面标志）打包到这个短整数中。各个标志值如下</code></p>
<p>0x01 Log file in use，U</p>
<p>0x02 Current log file，L</p>
<p>0x04 Backed up，B</p>
<p>0x08 Newly added (archive required)</p>
<p>0x10 Log has been written to an archive tape</p>
<p>0x20 Log is a temporary log file</p>
<p>Note that <strong>oncheck -pr</strong> is nice enough to print an English translation of all flag values present in the one value shown.</p>
<p><code>请注意，oncheck -pr 非常友好，会在显示的一个值中打印所有标志值的英文翻译。(数字右边就是)</code></p>
<p><strong>Physical location</strong> (decimal:decimal) – This is the physical location (chunk number and offset) of this log file’s first page.</p>
<p><code>这是日志文件第一页的物理位置（chunk编号和偏移量）。就是当前逻辑日志文件第一页在chunk的物理位置</code></p>
<p><strong>Log size</strong> (decimal) – This indicates the size of this log file, in pages.</p>
<p><code>表示该日志文件的大小（以页为单位）。</code></p>
<p><strong>Number pages used</strong> (decimal) – This element of the log file structure is fairly self-explanatory, though not always very accurate, being updated only during a checkpoint along with the rest of the reserved page information (when wrong, it is low). Informix Dynamic Server’s recovery mechanisms do not rely on this value at all.</p>
<p><code> 日志文件结构中的这一元素不言自明，但并不总是非常准确，只有在检查点期间才会与其他保留页信息一起更新（错误时，它的值较低）。IDS 的恢复机制完全不依赖这个值。</code></p>
<p>不懂，先不管</p>
<blockquote>
<p>fairly 相当地 英[ˈfeəli] 美[ˈferli]</p>
<p>self-explanatory 一目了然的 英[ˌself ɪkˈsplænətri] 美[ˌself ɪkˈsplænətɔːri]</p>
</blockquote>
<p><strong>Date&#x2F;time file filled</strong> – This is the date and time, based on the UNIX host’s <strong>localtime</strong>function, when this log file was filled. <strong>12&#x2F;31&#x2F;69 16:00</strong> indicates this element’s value is 0, which means the log file is either free or still in use.</p>
<p><code>根据 UNIX 主机的 localtime 函数，这是日志文件被写满时的日期和时间。&quot;-&quot; 表示此元素的值为 0，这意味着日志文件已空闲或仍在使用中。</code></p>
<p>原文的12&#x2F;31&#x2F;69 16:00不知道是什么，明明显示的是个”-“</p>
<p><strong>Time stamp</strong> (decimal) – This is the value of the global system timestamp when this log file was completed (the log file does not have to be filled to capacity to get a timestamp). A 0 here indicates a log file that is either free, or still in use.</p>
<p><code>这是该日志文件完成时的全局系统时间戳值（日志文件不必写满就可以获得时间戳）。此处的 0 表示日志文件空闲或仍在使用中。</code></p>
<p>说的是 onmode -l 情况吧</p>
<p><strong>Log Unique Identifier Versus Log File Number</strong></p>
<blockquote>
<p>versus 英[ˈvɜːsəs] 美[ˈvɜːrsəs]<br>prep.(表示两队或双方对阵)对，诉，对抗;(比较两种不同想法、选择等)与…相对，与…相比;</p>
</blockquote>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505112026087.png" alt="image-20250511202616915"></p>
<p><strong>Notes:</strong></p>
<p>A logical log file is an area on disk. It is a chunk extent, LOGSIZE kilobytes large, to which log records are written as they are generated. Each log file has a permanent log file number. In the example above, the log file number is 1 for the first log file, 2 for the second log, and 3 for the third log.</p>
<p><code>逻辑日志文件是磁盘上的一个区域。它是一个chunk extent，LOGSIZE 为 KB，日志记录生成后会被写入其中。每个日志文件都有一个永久的日志文件编号。在上例中，第一个日志文件的日志文件编号为 1，第二个日志文件的日志文件编号为 2，第三个日志文件的日志文件编号为 3。</code></p>
<p>In addition, each log file has a unique identifier, which you can think of as a method to uniquely tag the logical log records inside of the log. When a logical log is backed up, it carries its unique identifier with it. The unique identifiers for the logs on disk are incremented, ready for new transaction records.</p>
<p><code>此外，每个日志文件都有一个唯一标识符，可以将其视为唯一标记日志内逻辑日志记录的方法。备份逻辑日志时，日志会携带这个唯一标识符。磁盘上日志的唯一标识符会递增，为新的事务记录做好准备。</code></p>
<p>前半段看不懂，感觉按它意思，唯一标识日志里的逻辑日志记录，备份以后唯一标识递增（变了），而此时日志里内容没变吧，也就是内容没变的情况下，却不能唯一标识了，意思里面内容没用了呗，等新的事物记录写入</p>
<p>In the example above, the newly initialized Informix Dynamic Server system assigns the first log a unique ID of 1, the second log a unique ID of 2, and the third log a unique ID of 3. When these logs are full and you back them up to tape, the unique identifiers for the three logs are changed to 4, 5, and 6. After filling them a second time and backing them up, the unique identifiers are changed to 7, 8, and 9.</p>
<p><code>在上面的示例中，新初始化的 IDS 系统为第一个日志分配了唯一标识符 1，为第二个日志分配了标识符 2，为第三个日志分配了标识符 3。当这些日志被写满并备份到磁带后，这三个日志的唯一标识符会被更改为 4、5 和 6。在第二次写满并备份之后，唯一标识符会更改为 7、8 和 9。</code></p>
<p><strong>The Dbspace Page</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Validating PAGE_1DBSP &amp; PAGE_2DBSP...</span><br><span class="line">      Using DBspace page PAGE_2DBSP.</span><br><span class="line"></span><br><span class="line">DBspace number                 1</span><br><span class="line">DBspace name                   rootdbs</span><br><span class="line">Flags                          0x40001    No mirror chunks</span><br><span class="line">Number of chunks               1</span><br><span class="line">First chunk                    1</span><br><span class="line">Date/Time created              04/17/2025 08:44:48</span><br><span class="line">Partition table page number    14</span><br><span class="line">Pagesize (k)                   2</span><br><span class="line">Logical Log Unique Id          0</span><br><span class="line">Logical Log Position           0x0</span><br><span class="line">Oldest Logical Log Unique Id   155</span><br><span class="line">Last Logical Log Unique Id     0</span><br><span class="line">Expand Size (Chunk Create)     50.0%</span><br><span class="line">Expand size (Chunk Extend)     10.0%</span><br><span class="line">DBspace archive status</span><br><span class="line"></span><br><span class="line">      Archive Level            0</span><br><span class="line">      Real Time Archive Began  05/12/2025 07:25:01</span><br><span class="line">      Time Stamp Archive Began 8590386</span><br><span class="line">      Logical Log Unique Id    155</span><br><span class="line">      Logical Log Position     0x64f018</span><br></pre></td></tr></table></figure>

<p><strong>Notes:</strong></p>
<p>The dbspace structure is easier to understand intuitively than either the checkpoint or the log file structure.</p>
<p><code>与检查点或log file structure相比，dbspace 结构更容易直观地理解。</code></p>
<blockquote>
<p>intuitively 英[ɪnˈtjuːɪtɪvli] 美[ɪnˈtuːɪtɪvli]<br>adv.凭直觉;直觉地，直观地；由直觉而得地;</p>
</blockquote>
<p><strong>Dbspace number</strong> (decimal) – Dbspace numbers are indexed from 1.</p>
<p><strong>Dbspace name</strong> – This is the name given the dbspace when it was created, and the name used in all SQL syntax referring to this dbspace.</p>
<p><code>这是创建 dbspace 时赋予它的名称，也是所有引用该 dbspace 的 SQL 语法中使用的名称。</code></p>
<p><strong>Flags</strong> (hex) – The possible values for dbspace flags are:</p>
<p>0x0001 DBspace has no mirror chunks</p>
<p>0x0002 DBspace uses mirror chunks</p>
<p>0x0004 DBspace has disabled mirror chunks</p>
<p>0x0008 Newly mirrored</p>
<p>Flags specific to blobspaces:</p>
<p>0x0010 DBspace is a BLOBspace</p>
<p>0x0020 BLOBspace resides on removable media</p>
<p>0x0040 BLOBspace resides on optical media</p>
<p>0x0080 BLOBspace has been dropped</p>
<p>0x0100 BLOBspace is the optical STAGEBLOB</p>
<p>Other flags:</p>
<p>0x0200 Space is being physically recovered</p>
<p>0x0400 Space has been physically recovered</p>
<p>0x0800 Space is being logically recovered</p>
<p>0x1000 A table in the dbspace was dropped</p>
<p>0x2000 Temp DBspace</p>
<p>0x4000 Space is being archived</p>
<p>0x8000 Space is an sbspace</p>
<p>0x10000 Either the physical or logical log has changed</p>
<p>按这说的，那应该是0x10001，怎么是0x70001？</p>
<p><strong>Number of chunks</strong> (decimal) – This indicates the total number of chunks in this dbspace (not counting mirror chunks).</p>
<p><code>表示该数据库空间中的chunk总数（不包括镜像chunk）。</code></p>
<p><strong>First chunk</strong> (decimal) – The concept of a <em>first chunk</em> in a dbspace is important internally because a dbspace structure and all its associated primary chunk structures form a linked list. From the <strong>First chunk</strong> element in a dbspace structure, Informix Dynamic Server can quickly find the first primary chunk structure associated with this dbspace. Then, based on the <strong>Next chunk</strong> in dbspace element in each primary chunk structure, Informix Dynamic Server can quickly walk down the rest of the list.</p>
<p><code>dbspace 中的 first chunk 概念在内部非常重要，因为 dbspace 结构及其所有关联的主 chunk 结构构成了一个链表。IDS 可以通过 dbspace 结构中的 First chunk 元素，快速找到与该数据表空间相关联的 first primary chunk structure。然后，根据每个 primary chunk structure 中 dbspace 的 Next chunk 元素，IDS 可以快速找到列表的其余部分。</code></p>
<p><strong>Date&#x2F;time created</strong> – This is the date and time, based on the UNIX <strong>localtime</strong> function, when the dbspace was created.</p>
<p><code>这是创建 dbspace 的日期和时间，基于 UNIX 的 localtime 函数。</code></p>
<p><strong>Partition table page numbe</strong>r – This indicates the location of the first page of the partition partition as a page offset into the first chunk of the dbspace.</p>
<p><code>这表示 partition 第一页的位置，作为 dbspace 第一个 chunk 的页面偏移量。</code></p>
<p>两个连着的partition，多写了一个吧</p>
<p><strong>Pagesize (k)</strong> – This is the page size defined for this dbspace.</p>
<p><strong>Logical Log Unique ID</strong> and <strong>Logical Log Position</strong> – These fields indicate the location of the ADDDBS transaction record for this dbspace.</p>
<p><code>这些字段表示该 dbspace 的 ADDDBS 事务记录的位置。</code></p>
<p>看不懂</p>
<p><strong>Oldest Logical Log Unique ID</strong> and <strong>Last Logical Log Unique ID</strong> – These indicate the unique ID numbers of the oldest and most current logical logs.</p>
<p><code>这表示最旧和最新逻辑日志的唯一 ID 编号。</code></p>
<p><strong>Dbspace archive status</strong> – This displays information about the last backup that was performed that included this dbspace. Information includes the backup level, the start and end time of the backup, and the location of the backup checkpoint record.</p>
<p><code>这将显示上一次执行的包含此 dbspace 的备份信息。信息包括备份级别、备份开始和结束时间以及备份 checkpoint record 的位置。</code></p>
<p>没看出来哪个是结束时间</p>
<p>最后两个逻辑日志相关参数代表 the location of the backup checkpoint record 吧</p>
<p><strong>The Primary Chunk Page</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   Validating PAGE_1PCHUNK &amp; PAGE_2PCHUNK...</span><br><span class="line">         Using primary chunk page PAGE_1PCHUNK.</span><br><span class="line"></span><br><span class="line">   Chunk number                   1</span><br><span class="line">   Flags                          0x30040    Chunk is online</span><br><span class="line">   Chunk path                     /opt/gbase/storage/rootdbs</span><br><span class="line">   Chunk offset                   0 (p)</span><br><span class="line">   Chunk size                     78848 (p)</span><br><span class="line">   Number of free pages           64144</span><br><span class="line">   DBspace number                 1</span><br><span class="line"></span><br><span class="line">   Chunk number                   2</span><br><span class="line">   Flags                          0x32040    Chunk is online</span><br><span class="line">   &amp;                                         Chunk is extendable</span><br><span class="line">   Chunk path                     /opt/gbase/storage/ol_gbasedbt1210_1_plog_p_1</span><br><span class="line">   Chunk offset                   0 (p)</span><br><span class="line">   Chunk size                     36045 (p)</span><br><span class="line">   Number of free pages           6</span><br><span class="line">   DBspace number                 2</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p><strong>Notes:</strong></p>
<p>The primary chunk page contains information about each primary chunk created on the database server.</p>
<p><code>主chunk页面包含在server上创建的每个主chunk的信息。</code></p>
<p><strong>Chunk number</strong> (decimal) – Chunk numbers are indexed from 1, whereas page offsets begin with 0. The lowest possible value for a page address is therefore 1:0.</p>
<p><code>chunk编号的索引从 1 开始，而页面偏移量则从 0 开始。 因此，页面地址的最小值可能是 1:0。</code></p>
<p><strong>Flags</strong> (hex) – Individual chunk flags, ORed together into this one element, have the following values:</p>
<p><code>各个独立的chunk标志通过按位或操作（OR）组合在一起，形成这个元素，具有以下值：</code></p>
<p>0x0010 Mirror chunk</p>
<p>0x0020 Chunk is off-line</p>
<p>0x0040 Chunk is on-line</p>
<p>0x0080 Chunk is being recovered</p>
<p>0x0100 Chunk is newly mirrored</p>
<p>0x0200 Chunk is belongs to a blobspace</p>
<p>0x0400 Chunk is being dropped</p>
<p>0x0800 Chunk is part of an optical stageblob</p>
<p>0x1000 Chunk is inconsistent with the rest of the system</p>
<p>0x2000 Chunk has been chained</p>
<p>0x4000 Chunk belongs to an sbspace</p>
<p><strong>Chunk path</strong> – This is the full pathname to the chunk device or file. </p>
<p><code>这是chunk设备或文件的完整路径名。</code></p>
<p><strong>Chunk offset</strong> (decimal) – This chunk begins at <strong>Chunk offset</strong> <em>pages</em> into <strong>Chunk path</strong>.</p>
<p><code>该chunk从 Chunk path 中偏移 Chunk offset 页的位置开始。</code></p>
<p><strong>Chunk size</strong> (decimal) – This indicates the size of the chunk in <em>pages</em>.</p>
<p><code>这表示数据块的大小，单位为页。</code></p>
<p><strong>Number of free pages</strong> (decimal) – This indicates the total number of pages currently in the chunk free list.</p>
<p>·这表示当前chunk free list的页面总数。·</p>
<p><strong>Dbspace number</strong> (decimal) – This is the unique dbspace number.</p>
<p><code>这是唯一的dbspace编号。</code></p>
<p><strong>The Mirror Chunk Page</strong></p>
<p>没人用 Mirror Chunk 了吧，跳过不看</p>
<p><strong>The Archive Page</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Validating PAGE_1ARCH &amp; PAGE_2ARCH...</span><br><span class="line">         Using archive page PAGE_1ARCH.</span><br><span class="line"></span><br><span class="line">   Archive Level                  0</span><br><span class="line">   Real Time Archive Began        05/12/2025 07:25:01</span><br><span class="line">   Time Stamp Archive Began       0x831432</span><br><span class="line">   Logical Log Unique Id          155</span><br><span class="line">   Logical Log Position           0x64f018</span><br><span class="line"></span><br><span class="line">   Archive Level                  1</span><br><span class="line">   Real Time Archive Began        05/12/2025 07:25:52</span><br><span class="line">   Time Stamp Archive Began       0x8314b5</span><br><span class="line">   Logical Log Unique Id          155</span><br><span class="line">   Logical Log Position           0x656018</span><br><span class="line"></span><br><span class="line">   DR has not been initialized.</span><br></pre></td></tr></table></figure>

<p><strong>Notes:</strong></p>
<p>The archive reserved page is the last in the set of root reserved pages. Up to three archive structures can be present on the page, depending on the level of archives taken on the system. Once a second or third archive structure comes to exist on the page, it is never deleted because a new level-0 archive does not negate the potential importance of a previous level 1 or level 2 archive.</p>
<p><code>存档预留页是root预留页中的最后一个。页面上最多可有三个存档结构，具体取决于系统中存档的级别。一旦页面上出现第二个或第三个存档结构，它将永远不会被删除，因为新的 0 级存档不会否定之前的 1 级或 2 级存档的潜在重要性。</code></p>
<p>看不懂，对应0、1、2级备份吧</p>
<p>New information is recorded in the archive reserved page only when an archive completes successfully.</p>
<p><code>只有当存档成功完成时，存档保留页面才会记录新信息。</code></p>
<p><strong>Archive Level</strong> (decimal) – This can be level 0, 1, or 2.</p>
<p><strong>Real Time Archive Began</strong> – This indicates the date and time of the archive checkpoint as seen by the localtime function on the UNIX host machine.</p>
<p><code>这表示存档检查点的日期和时间，由 UNIX 主机上的 localtime 功能显示。</code></p>
<p>看不懂，什么叫存档检查点？从名字看就是备份时间吧</p>
<p><strong>Time Stamp Archive Began</strong> (decimal) – This is a timestamp associated with the checkpoint that occurred at the start of the archive.</p>
<p><code>这是与存档开始时发生的检查点相关联的时间戳。</code></p>
<p>看不懂</p>
<p><strong>Logical Log Unique Id</strong> (decimal) – This is the unique ID of the logical log that contains the archive checkpoint record.</p>
<p><code>这是包含 archive checkpoint record 的逻辑日志的唯一 ID。</code></p>
<p><strong>Logical Log Position</strong> (hex) – This is the position within the log (logpos) specified by logical log unique ID where the archive checkpoint can be found.</p>
<p><code>这是在逻辑日志唯一 ID 指定的日志 (logpos) 中可以找到 archive checkpoint 的位置。</code></p>
<p><strong>Chunk Free List</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505132122121.png" alt="image-20250513212245968"></p>
<p><strong>Notes:</strong></p>
<p>Every chunk needs a mechanism to track its own available space. Following the last reserved page in each chunk is a chunk free-list page. This page, which can be one of several depending on the fragmentation in the chunk, contains structures pointing to <em>unused</em> extents. Each structure, or <em>free-list entry</em>, contains two elements: the starting page of an unclaimed extent, and the length of the free extent measured in pages.</p>
<p><code>每个 chunk 都需要一种机制来跟踪自己的可用空间。在每个chunk的最后一个预留页之后是一个 chunk free-list page。该页面可以是多个页面之一，取决于 chunk 中的碎片情况，包含指向未使用extent的结构。每个结构或free-list条目包含两个元素：空闲extent的起始页和空闲extent的长度（以页为单位）。</code></p>
<p>“该页面可以是多个页面之一”，多个翻译软件都是这么翻译的，不像人话，意思应该是可能有多个chunk free-list page，如果碎片很多的话，要记录很多的起始和偏移，一页放不下，如果一个碎片都没有，一个起始和偏移就够了。</p>
<blockquote>
<p>unclaimed 英[ˌʌnˈkleɪmd] 美[ˌʌnˈkleɪmd]<br>adj.无人认领的;无人索取的;</p>
</blockquote>
<p><strong>Allocation of space</strong></p>
<p>When an extent is allocated in a chunk, the loss of free space is manifested in either the removal of an entry from the chunk free list, or a modification to one or both elements in an entry there.</p>
<p>当在chunk中分配一个extent时，可用空间的损失表现为从chunk free list中删除一个条目，或修改该条目中的一个或两个元素。</p>
<blockquote>
<p>manifest<br>英[ˈmænɪfest] 美[ˈmænɪfest]<br>vt.表明;显示;显现;清楚显示(尤指情感、态度或品质);使人注意到;<br>adj.明显的;<br>n.(船或飞机的)货单;旅客名单;</p>
<p>以前都按java的<em>MANIFEST</em>.MF理解为：清单</p>
</blockquote>
<p><strong>Freeing space</strong></p>
<p>Informix Dynamic Server frees space when a table is dropped, or in some cases when a table is altered. When free space is reclaimed, a new entry can be added to the chunk free list. If the newly freed space is contiguous with existing free space, only the length element in the associated free-list entry is changed; otherwise, a new entry is created.</p>
<p><code>IDS 会在删除表或在某些情况下更改表时释放空间。当空闲空间被回收时，可以在chunk free list中添加一个新条目。如果新释放的空间与现有的空闲空间毗连，则只更改相关空闲列表条目中的长度元素；否则，将创建一个新条目。</code></p>
<blockquote>
<p>reclaim<br>英[rɪˈkleɪm] 美[rɪˈkleɪm]<br>vt.回收;开垦，利用，改造(荒地);取回;挽救;要求归还;拿回;沙化;荒漠化;重新变为沙漠(或森林等);抛荒;<br>n.开垦;改造;取回;矫正;</p>
</blockquote>
<p><strong>Additional chunk free-list pages</strong></p>
<p>If a chunk becomes so fragmented that the initial chunk free-list page is full of entries, an additional chunk free-list page is allocated. These pages are then chained together in the form of a linked list. Each link in this chain is responsible only for extents between itself and the next chunk free-list page. This design requires a good deal of coordination among the links.</p>
<p><code>如果一个分块变得非常分散，以至于初始chunk free-list page已经满载条目，那么就会分配一个额外的chunk free-list page。然后，这些页面以链表的形式串联起来。链中的每个链接只负责自身和下一个chunk free-list page之间的扩展。这种设计要求链路之间有很好的协调性。</code></p>
<p><strong>Tblspace Tblspace (for Root Dbspace)</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505132157873.png" alt="image-20250513215730788"></p>
<p><strong>Notes:</strong></p>
<p>In the initial chunk of every dbspace, the page following the chunk free list marks the beginning of the tblspace tblspace (partition table). The tblspace tblspace is a collection of pages that describes the complexion and location of each table in the dbspace. In many ways, the tblspace tblspace itself is considered just another table. For example, one of its pages describes the tblspace tblspace!</p>
<p><code>在每个 dbspace 的初始chunk中，数据chunk free list之后的页面标志着 tblspace tblspace（分区表）的开始。tblspace tblspace 是描述 dbspace 中每个表的结构和位置的页面集合。在许多方面，tblspace tblspace 本身就被认为是另一个表。例如，其中一个页面描述了 tblspace tblspace！</code></p>
<blockquote>
<p>complexion<br>英[kəmˈplekʃn] 美[kəmˈplekʃn]<br>n.肤色;面色;气色;(事物的)性质，特性;</p>
<ul>
<li><em>complex</em> 的“复杂性”含义源于“多元素交织”的原始意象。</li>
<li><em>complexion</em> 的中世纪生理学概念认为体液混合决定面色，故从“混合状态”引申为“肤色”。</li>
</ul>
</blockquote>
<p>You can configure the size of the first and subsequent extents for the tblspace tblspace in by setting the TBLTBLFIRST and TBLTBLNEXT configuration parameters. The default value of 0 directs the database server to determine appropriate extent sizes based on the size of the initial dbspace chunk.</p>
<p><code>通过设置 TBLTBLFIRST 和 TBLTBLNEXT 配置参数，可以配置 tblspace tblspace 中第一个和后续extent的大小。默认值 0 会指示server根据初始 dbspace chunk 的大小确定适当的extent大小。</code></p>
<p>Every tblspace in the system has exactly one tblspace tblspace page describing it. For brevity’s sake, we often refer to this special page type as a <em>partition page</em>.</p>
<p><code>系统中的每个 tblspace 都有且只有一个 tblspace tblspace page 来描述它。为了简洁起见，我们通常将这种特殊类型的页面称为 分区页（partition page）。</code></p>
<p>上图大方格那一行page</p>
<p><strong>Partition Number (Partnum)</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505142301023.png" alt="image-20250514230139875"></p>
<p><strong>Notes:</strong></p>
<p>The purpose of a table’s partition number, another 4-byte hexadecimal code, is to guide Informix Dynamic Server to that table’s partition page in the tblspace tblspace. The high-order byte-and-a-half (3 nibbles) of a partnum indicates which dbspace contains the table. Using the value of that byte-and-a-half, Informix Dynamic Server locates the tblspace tblspace for the target dbspace. One of the pages in that tblspace tblspace describes the target table. Informix Dynamic Server locates the correct partition page using the low-order five nibbles of the partnum, which contain a logical page number.</p>
<p><code>表的 partition number 是一个4字节的十六进制代码，其作用是引导 IDS 定位到该表在 tblspace tblspace 中的 partition page。这个 partnum 的高一字节半（3个半字节）用于指示表所在的 dbspace。通过这个高一字节半的值，IDS 可以定位到目标 dbspace 所对应的 tblspace tblspace。该 tblspace tblspace 中的某个页面描述了目标表。IDS 再通过分区号的低五个半字节——即逻辑页码，来定位到正确的 partition page。</code></p>
<blockquote>
<p>nibble 英[ˈnɪbl] 美[ˈnɪbl]</p>
<p>半字节</p>
<p>v.小口咬;一点点地咬(食物);(对…)略微表现出兴趣;<br>n.一小口;小吃;(餐前或聚会中的)点心;</p>
</blockquote>
<p>上上个图，partition number还是3字节，到这边4字节了…</p>
<p>Let us say the <strong>stores_demo:customer</strong> table has a partition number of 0x001000A5. This code means that logical page 0xA5 (165) within the tblspace tblspace for dbspace 1 is the partition page for <strong>stores_demo:customer</strong>.</p>
<p><code>例如，stores_demo:customer 表的分区号为 0x001000A5。这段代码表示，dbspace 1 的 tblspace tblspace 中的逻辑页 0xA5 (165) 是 stores_demo:customer 的 partition page。</code></p>
<p><strong>Partition Page Layout</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505152133530.png" alt="image-20250515213343393"></p>
<p><strong>Notes:</strong></p>
<p>Each partition page uses the following 5-slot format to describe the structure, location, and contents of one table in the dbspace:</p>
<p><code>每个 partition page 使用以下 5 个slot的格式来描述 dbspace 中一个表的结构、位置和内容：</code></p>
<p><strong>•</strong> The partition structure (slot 1) contains 92 bytes of general table information, including the partition number (see next page).</p>
<p><code>partition structure（slot 1）包含 92 个字节的常规表信息，包括分区编号（见下页，往后边看有详细解释）。</code></p>
<p><strong>•</strong> Slot 2 contains information identifying the partition by database name, table owner, table name, and NLS collation sequence (if any).</p>
<p><code>Slot 2 包含用于标识 partition 的信息，包括数据库名称、表拥有者、表名称，以及 NLS 排序规则（如果有的话）。</code></p>
<p><strong>•</strong> Slot 3 contains a descriptive entry for each <em>special</em> column in the table, meaning blobs and VARCHAR types.</p>
<p><code>slot 3 包含表中每个特殊列的描述性条目，即 blobs 和 VARCHAR 类型。</code></p>
<p><strong>•</strong> Slot 4 contains a <em>key descriptor</em> entry for each index key that exists for this table. Therefore, when accessing a particular tblspace, an error such as <em>Illegal key descriptor:</em> <em>too many parts or too long</em> refers to a problem with slot 4 on that table’s partition page, and not with the index itself. Because dropping an index requires the use of its key descriptor, a bad key descriptor can sometimes require the intervention of IBM Informix Technical Support to fix.</p>
<p><code>Slot 4 包含该表中每个索引键的“键描述符”（key descriptor）条目。因此，当访问某个特定的表空间（tblspace）时，若出现类似 非法键描述符（Illegal key descriptor）：part过多或过长（too many parts or too long） 的错误，通常说明该表的分区页上的 Slot 4 出现了问题，而不是索引本身存在问题。由于删除索引时需要使用其键描述符（key descriptor），因此损坏的键描述符有时需要 IBM Informix 技术支持介入才能修复。</code></p>
<p><strong>•</strong> Slot 5 contains extent information. Each 8-byte entry in this slot includes:</p>
<p><code>slot 5 包含 extent 信息。该 slot 中的每个 8 字节条目包括</code></p>
<p>​     <strong>-</strong> the logical page number of that extent’s first page within the tblspace (4 bytes)</p>
<p>​    <code>tblspace 中该 extent 第一页的逻辑页码（4 个字节）</code></p>
<p>​     <strong>-</strong> the page offset of the extent into the dbspace (4 bytes)</p>
<p>​    <code>dbspace 中 extent 的页面偏移量（4 个字节）</code></p>
<p>​    The slot also includes one “on-deck” entry that includes the logical page number for the next extent allocated.</p>
<p>​    <code>slot还包括一个 “on-deck ”条目，其中包括下一个已分配extent的逻辑页码。</code></p>
<p>​	slot 5 看不懂</p>
<p>A table could also have a sixth slot, but it does not appear on the main partition page for that table. The sixth slot is used to describe different versions of extents that result from altering a table in-place. This slot appears on a separate page in the tblspace tblspace.</p>
<p><code>表也可以有第六个slot，但它不会出现在该表的 main partition page 上。第六个 slot 于描述因就地更改表而产生的不同 extent 版本。该 slot 在 tblspace tblspace 中的一个单独页面上。</code></p>
<p>什么叫 main partition page，第一页？</p>
<p><strong>Slot 1: The Partition Structure</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">TBLspace Report <span class="keyword">for</span> testdb:root.t1</span><br><span class="line"></span><br><span class="line">    Physical Address               13:570</span><br><span class="line">    Creation <span class="built_in">date</span>                  05/08/2025 05:05:57</span><br><span class="line">    TBLspace Flags                 902        Row Locking</span><br><span class="line">                                              TBLspace contains VARCHARS</span><br><span class="line">                                              TBLspace use 4 bit bit-maps</span><br><span class="line">    Maximum row size               16</span><br><span class="line">    Number of special columns      1</span><br><span class="line">    Number of keys                 0</span><br><span class="line">    Number of extents              1</span><br><span class="line">    Current serial value           1</span><br><span class="line">    Current SERIAL8 value          1</span><br><span class="line">    Current BIGSERIAL value        1</span><br><span class="line">    Current REFID value            1</span><br><span class="line">    Pagesize (k)                   2</span><br><span class="line">    First extent size              8</span><br><span class="line">    Next extent size               8</span><br><span class="line">    Number of pages allocated      8</span><br><span class="line">    Number of pages used           2</span><br><span class="line">    Number of data pages           1</span><br><span class="line">    Number of rows                 4</span><br><span class="line">    Partition partnum              13631559</span><br><span class="line">    Partition lockid               13631559</span><br><span class="line"></span><br><span class="line">    Extents</span><br><span class="line">         Logical Page     Physical Page        Size Physical Pages</span><br><span class="line">                    0           13:2087           8          8</span><br></pre></td></tr></table></figure>



<p><strong>Notes:</strong></p>
<p>The partition structure is stored in the first slot on every partition page and holds general information about the corresponding table. You can view the partition structure for any table by running the command:</p>
<p><code>partition structure 存储在每个 partition page 的第一个 slot 中，包含相应表的一般信息。运行该命令可以查看任何表的 partition structure：</code></p>
<p>​	oncheck -pt <em>database_name</em>:<em>table_name</em></p>
<p>Instead of a database and table name, you can provide a partition number:</p>
<p>​	oncheck -pt 1048672</p>
<p>The output of this command consists of slightly-massaged versions of the partition structure (slot 1) and the extent structure (slot 5) for the partition page. An example of <strong>oncheck</strong> output for the partition structure is shown in the slide above.</p>
<p><code>该命令的输出包括partition structure（slot 1）和 partition page 的 extent structure（slot 5）的略微简化版本（最后3行）。上面的幻灯片显示了 partition structure 的 oncheck 输出示例。</code></p>
<p>You might recognize some of the general tblspace information stored in the partition structure as table statistics, also stored in system catalogs for use by the optimizer. In fact, during some UPDATE STATISTICS operations, some information from a table’s partition page is copied into system catalogs, while other information must be gathered by reading the tblspace pages themselves. Although the system catalog information can become out of date as the table grows and changes, the information on the partition page should always be accurate. However, the optimizer code is meant to be portable across Informix servers and it, therefore, does not know how to access a partition page. As far as the optimizer is concerned, the only table statistics available are stored in system catalogs.</p>
<p><code>你可能会注意到，partition structure 中存储的一些通用表空间（tblspace）信息，与存储在系统目录（system catalogs）中的表统计信息相似，这些统计信息被优化器（optimizer）用于优化查询。实际上，在某些 </code>UPDATE STATISTICS<code> 操作中，部分表的分区页（partition page）中的信息会被复制到 system catalogs 中，而其他信息则必须通过读取表空间页（tblspace pages）来收集。尽管系统目录中的信息可能会随着表的增长和变化而变得过时，partition page 中的信息应始终是准确的。然而，优化器的代码是为了在不同的 Informix server 之间具备可移植性，因此它并不了解如何访问 partition page。就优化器而言，唯一可用的表统计信息就是存储在 system catalogs 中的那些。</code></p>
<blockquote>
<p>gather 聚集 英[ˈɡæðə(r)] 美[ˈɡæðər]</p>
</blockquote>
<p>前边说，为了简洁，把 tblspace tblspace page 叫做 partition page，那 tblspace pages 是什么？先不管它，好像 Unit 4 有讲</p>
<p><strong>Physical Address</strong> (decimal:decimal) – This is not the partition number, nor is it an address related to any tblspace extent. Unlike the rest of the elements displayed, the physical address is not even part of the partition structure. The oncheck report is simply displaying the physical location (chunk number and page offset) of the partition page from which the rest of the information has been taken.</p>
<p><code>这不是 partition number，也不是与任何 tblspace extent 相关的地址。与显示的其他元素不同，物理地址甚至不是 partition structure 的一部分。oncheck 只是显示 partition page 的物理位置（chunk number 和 page offset），其他信息都是从该页面获取的。</code></p>
<p><strong>Creation date</strong> – This is the date and time this table was created.</p>
<p><code>这是该表的创建日期和时间。</code></p>
<p><strong>TBLSpace Flags</strong> (decimal) – These flags operate as page flags, dbspace flags, and chunk flags do, coagulating in one integer with the help of the logical OR. Individual tblspace flags have the following values and meanings:</p>
<p><code>这些 flags 与 page flags, dbspace flags 和 chunk flags 一样，在逻辑 OR 的帮助下合并为一个整数。各个 tblspace 标志的值和含义如下：</code></p>
<blockquote>
<p>coagulate 英[kəʊˈæɡjuleɪt] 美[koʊˈæɡjuleɪt]<br>v.(使)凝结，凝固;<br>n.（&#x3D;coagulum）凝结物(如血块);<br>adj.&lt;古&gt;凝结的;</p>
</blockquote>
<p>0x0001 Page-level locking</p>
<p><code>页级锁</code></p>
<p>0x0002 Row-level locking</p>
<p><code>行级锁</code></p>
<p>0x0004 Tblspace is a Bundlespace (OnLine secure)</p>
<p>看不懂</p>
<p>0x0008 Partition marked for DDR replication</p>
<p>和ER有关吧，看不懂</p>
<p>0x0010 Partition dropped (shared memory only)</p>
<p>0x0020 System-defined temporary table</p>
<p>0x0040 User-defined temporary table</p>
<p>0x0080 Tblspace used for sorting</p>
<p>0x0100 Contains VARCHAR column(s)</p>
<p>0x0200 Contains BLOBspace BLOB column(s)</p>
<p>0x0400 Contains partition-resident BLOB column(s)</p>
<p>0x0800 Requires 4-bit bitmap</p>
<p>0x1000 Contains optical BLOB column(s)</p>
<p>0x2000 Partition required for system to function - do not drop</p>
<p>0x4000 Temp table being used for special function - do not update</p>
<p>0x8000 Partition is being appended to</p>
<p><strong>Maximum row size</strong> (decimal) – For tables with fixed-length rows, this value is simply the row size in bytes. The concept of a <em>maximum</em> row size becomes necessary only when a tblspace contains VARCHAR columns. Recall that a VARCHAR column is defined with a minimum and a maximum size, in units of characters, which is equivalent to bytes. The maximum size of a VARCHAR column, plus one byte of overhead (in which to store the actual size of the VARCHAR data) is added with the sizes of the other columns in the schema to arrive at this <em>maximum row size</em> figure.</p>
<p><code>对于具有固定长度行的表，该值就是以字节为单位的行大小。只有当 tblspace 包含 VARCHAR 列时，才有必要使用最大行大小的概念。回想一下，VARCHAR 列的最小和最大大小是以字符为单位定义的，相当于字节。VARCHAR 列的最大大小加上一个字节的开销（用于存储 VARCHAR 数据的实际大小），再加上模式中其他列的大小，就得出了最大行大小这个数字。</code></p>
<blockquote>
<p>figure 英[ˈfɪɡə(r)] 美[ˈfɪɡjər]<br>n.图形;人物;人，动物;（书中的）图，表;身材;位数;花样;（远处人的）轮廓;（人、动物的）雕像，塑像;算术;数字符号;字码;(代表数量，尤指官方资料中的)数字;<br>v.是…的部分;计算(数量或成本);认为，认定(某事将发生或属实);是重要部分;</p>
</blockquote>
<p>知乎这回答应该是oracle里schema的概念。IX9111这段中的schema先理解成包含columns的数据库对象吧，如：表</p>
<blockquote>
<p>知乎：</p>
<p>在学习数据库时，会遇到一个让人迷糊的Schema的概念。实际上，<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=72023897&content_type=Answer&match_order=1&q=schema&zhida_source=entity">schema</a>就是<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=72023897&content_type=Answer&match_order=1&q=%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1&zhida_source=entity">数据库对象</a>的集合，这个集合包含了各种对象如：表、视图、<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=72023897&content_type=Answer&match_order=1&q=%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B&zhida_source=entity">存储过程</a>、索引等。</p>
<p>如果把database看作是一个仓库，仓库很多房间（schema），一个schema代表一个房间，table可以看作是每个房间中的储物柜，user是每个schema的主人，有操作数据库中每个房间的权利，就是说每个数据库映射user有每个schema（房间）的钥匙。</p>
</blockquote>
<p><strong>Number of special columns</strong> (decimal) – Blob and VARCHAR columns are considered <em>special</em>, Informix Dynamic Server-only column types.</p>
<p><code>Blob 和 VARCHAR 列被认为是特殊的，仅限 IDS 使用的列类型。</code></p>
<p><strong>Number of keys</strong> (decimal) – The total number of indexes defined for the table. A composite index can be made from several columns, but still has only one index <em>key</em>.</p>
<p><code>为表定义的索引总数。复合索引可以由多个列组成，但仍然只有一个索引键。</code></p>
<p><strong>Number of extents</strong> (decimal) – The number of separate extents allocated to the table. Extent concatenation and doubling, and good tblspace management on the part of the Informix Dynamic Server administrator, tend to keep this number low. As the number of extents for a tblspace grows, not only can data be scattered unpredictably (a performance problem for sequential reads), but the extent slot on the partition page grows. An extent slot can contain only so many entries before it runs out of room. Because other slots on the partition page, such as slot 4, can also grow dynamically, there is no way to publish a maximum number of tblspace extents with any accuracy. Empirical evidence has shown the maximum number of extents on a 2K-page is approximately 190.</p>
<p><code>分配给表的独立extent的数量。extent的拼接与倍增（机制），以及 IDS 管理员对表空间（tblspace）的良好管理，往往能将这一数量保持在较低水平。随着 tblspace 的extent 数量增加，不仅数据会不可预测地分散（对于顺序读取来说是个性能问题），而且 partition page 上的 extent slot 也会增加。在空间耗尽之前，一个 extent slot 只能容纳这么多条目。由于 partition page 上的其他 slot（如 slot 4）也会动态增长，因此无法准确发布 tblspace extents 的最大数量。经验表明，2K 页面上的最大扩展项数量约为 190 个。</code></p>
<p>extent slot 是 slot 5 上 extent list 中的元素？</p>
<blockquote>
<p>scatter 分散 英[ˈskætə(r)] 美[ˈskætər]</p>
<p>predictably 可推断 美[prɪˈdɪktəbli]</p>
<p>empirical 英[ɪmˈpɪrɪkl] 美[ɪmˈpɪrɪkl] adj.经验主义的;以实验(或经验)为依据的;</p>
<p>approximately 大概 英[əˈprɒksɪmətli] 美[əˈprɑːksɪmətli]</p>
</blockquote>
<p><strong>Current serial value</strong> (decimal) – A tblspace can contain only one serial column. If one exists, this is the next value that is used for an insert. If there is no serial column in the table, this value remains 1.</p>
<p><code>一个 tblspace 只能包含一个 serial 列。如果存在 serial 列，则下一个值将用于插入。如果表中没有 serial 列，该值将保持为 1。</code></p>
<p><strong>First extent size</strong> (decimal) – This is the configured EXTENT SIZE, in units of Informix Dynamic Server pages. The units here can be a bit confusing because through SQL, one specifies EXTENT SIZE in kilobytes.</p>
<p><code>这是配置的 EXTENT SIZE，以 IDS page 为单位。这里的单位可能有点令人困惑，因为通过 SQL，我们可以用 KB 来指定 EXTENT SIZE。</code></p>
<p>The default EXTENT SIZE is 8 pages, regardless of the page size. The minimum extent size is 4 pages.</p>
<p><code>无论页面大小如何，默认 extent 大小为 8 页。最小 extent 大小为 4 页。</code></p>
<p><strong>Next extent size</strong> (decimal) – This is the configured NEXT SIZE, also in units of Informix Dynamic Server pages. Note that at the SQL level one specifies NEXT SIZE in units of kilobytes, so like First extent size, the value here is initially either half or one quarter the number used with the NEXT SIZE clause in SQL.</p>
<p><code>这是配置的 NEXT SIZE，也是以 IDS page 为单位。请注意，在 SQL 级别，NEXT SIZE 是以 KB 为单位指定的，因此与 First extent size 一样，这里的值最初是 SQL 中 NEXT SIZE 子句所用数字的一半或四分之一。</code></p>
<blockquote>
<p>chatgpt:</p>
<h3 id="具体解释如下："><a href="#具体解释如下：" class="headerlink" title="具体解释如下："></a>具体解释如下：</h3><ul>
<li>在 SQL 中，<code>NEXT SIZE</code> 是以 <strong>KB（千字节）</strong> 为单位指定的。</li>
<li>在内部，Informix 使用的是 <strong>页（page）</strong> 为单位的存储方式，比如常见的页大小是 <strong>2KB</strong> 或 <strong>4KB</strong>。</li>
</ul>
<h4 id="示例说明："><a href="#示例说明：" class="headerlink" title="示例说明："></a>示例说明：</h4><ul>
<li>如果你的数据库页大小是 <strong>2KB</strong>：<ul>
<li>你在 SQL 中写 <code>NEXT SIZE 64</code>（表示 64KB）；</li>
<li>那么转换成页就是：<code>64KB ÷ 2KB = 32 页</code>；</li>
<li>此时内部记录的 NEXT SIZE 就是 32。</li>
</ul>
</li>
<li>如果页大小是 <strong>4KB</strong>：<ul>
<li>同样的 SQL 指定 <code>NEXT SIZE 64</code>；</li>
<li>内部转换成页就是：<code>64KB ÷ 4KB = 16 页</code>；</li>
<li>所以内部值会是 16。</li>
</ul>
</li>
</ul>
<p>因此：</p>
<p>如果页大小是 2KB，则内部值是 SQL 值的一半；<br>如果页大小是 4KB，则内部值是 SQL 值的四分之一。</p>
</blockquote>
<p>Next extent size can increase over time due to extent size doubling. The size never decreases unless the table is deliberately altered. The default for the next extent size is 8 pages. The minimum extent size is 4 pages.</p>
<p><code>由于 extent 大小的倍增机制，Next extent size 可能会随着时间推移而增加。除非对表进行显式修改，否则该大小不会减少。Next extent size 的默认值是 8 页，最小值为 4 页。</code></p>
<blockquote>
<p>deliberately 故意 英[dɪˈlɪbərətli] 美[dɪˈlɪbərətli]</p>
</blockquote>
<p><strong>Number of pages allocated</strong> (decimal) – This is the total number of pages, whether used or not, contained in the extents allocated to the tblspace.</p>
<p><code>这是分配给表空间（tblspace）的所有 extent 中包含的页数总和，无论这些页是否已被使用。</code></p>
<p><strong>Number of pages used</strong> (decimal) – This is the maximum number of pages that have ever been used in the tblspace.</p>
<p><code>这是 tblspace 中使用过的最大页数。</code></p>
<p><strong>Number of data pages</strong> (decimal) – This is the number of data pages currently in use in the tblspace. When all rows are deleted from a data page, the page is freed for reuse in the tblspace, and the <strong>Number of data pages</strong> element of the partition structure is decremented.</p>
<p><code>这是当前在 tblspace 中使用的数据页数。当从数据页中删除所有行时，该页将被释放以供在 tblspace 中重复使用，并且 partition structure 中的“Number of data pages”元素将减少。</code></p>
<p><strong>Number of rows</strong> (decimal) – This indicates the number of rows in the tblspace.</p>
<p><code>这表示 tblspace 中的行数。</code></p>
<p><strong>Partition partnum</strong> (decimal) – This indicates the partition number of the tblspace.</p>
<p><code>这表示 tblspace 的 partition number。</code></p>
<p><strong>Partition lockid</strong> – It used to be that when you locked an Informix Dynamic Server table, you were really locking a partition number. This works as long as there is a one-to-one correspondence between database tables and Informix Dynamic Server partition numbers. But fragmentation allows many partitions to be associated with one database table. Rather than associate the partnums of every table fragment with a single table lock, Informix Dynamic Server uses this value, the lockid, to represent all table fragments.</p>
<p><code>过去，锁定 IDS 表时，实际上是锁定一个 partition number。只要数据库表和 IDS partition number 之间存在一一对应关系，这种方法就能奏效。但分片允许将许多 partition 与一个数据库表关联起来。IDS 不会将每个表片段的分区号与单个表锁相关联，而是使用 lockid 这个值来代表所有表片段。</code></p>
<p><strong>The Partition Page Location</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505171729739.png" alt="image-20250517172857535"></p>
<p><strong>Notes:</strong></p>
<p>Dynamic Server determines the location of a table’s partition page based on that table’s partition number, which is stored in <strong>systables.partnum</strong>. Upon reading a partition page, the database server can check that it has found the correct one by scanning the first 4-byte element in the partition structure. This first element contains the partition number. Here is an example:</p>
<p><code>IDS 根据表的 partition number 确定表的 partition page 位置，partition number 存储在 systables.partnum 中。读取 partition page 时，server 可通过扫描 partition structure 中的第一个 4 字节元素来检查是否找到了正确的 partition page。第一个元素包含 partition number。下面是一个示例：</code></p>
<ol>
<li><p>The database server receives a request to access the <strong>items</strong> table.</p>
<p><code>server 收到访问 items 表的请求。</code></p>
</li>
<li><p>In order to find the partition page for the <strong>items</strong> table, the server must determine its partition number. The database server selects the <strong>partnum</strong> value from <strong>systables</strong>.</p>
<p><code>为了找到 items 表的 partition page，server 必须确定其 partition number。server 从 systables 中查询 partnum 值。</code></p>
</li>
<li><p>Based on the partition number, a hex code comprised of a dbspace number and a logical page number, IDS reads a specific partition page from a specific tblspace tblspace.</p>
<p><code>根据partition number（由 dbspace 编号和逻辑页码组成的十六进制代码），IDS 会从特定的 tblspace tblspace 中读取特定的 partition page。</code></p>
</li>
<li><p>To check its work, the Dynamic Server process reads the first element of the partition structure found in slot 1 on the partition page, comparing the value found there against the partition number selected from <strong>systables</strong> during step 2 above.</p>
<p><code>为检查其工作，server 进程会读取 partition page slot 1 中 partition structure 的第一个元素，并将其中的值与上述第 2 步中从 systables 查询的 partition number 进行比较。</code></p>
</li>
<li><p>If the two partition numbers match, the operation has so far been successful. If they differ, the database server writes an assertion failure message to the message log and returns errors 242 and 135 to the client process.</p>
<p><code>如果两个 partition number 匹配，则操作成功。如果不一致，server 会在消息日志中写入断言失败消息，并向客户进程返回错误 242 和 135。</code></p>
</li>
</ol>
<p><strong>Slot 5: The Extent Slot</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505171743215.png" alt="image-20250517174318102"></p>
<p><strong>Notes:</strong></p>
<p>The extent slot, slot 5 of a partition page, is an array of 8-byte entries, each of which describes one extent for the table. The information stored in each 8-byte extent entry consists of two 4-byte values: the logical page number (within the tblspace) of the start of the extent, and the offset of that page into the dbspace.</p>
<p><code>extent slot（partition page 的第 5 slot）是一个 8 字节条目的数组，每个条目描述表的一个 extent。每个 8 字节 extent 条目中存储的信息由两个 4 字节值组成：extent 起始的逻辑页码（在 tblspace 中），以及该页在 dbspace 中的偏移量。</code></p>
<p>For instance, consider the following entry in the extent slot shown in the slide above (the display format is modified to make interpretation easier):</p>
<p><code>例如，请看上面幻灯片中显示的 extent slot 中的以下条目（为便于解释，对显示格式进行了修改）：</code></p>
<p>​		0000 0020 0000 0665</p>
<p>This entry describes an extent whose first page is located on the 1637th (0x665) page of dbspace number 1. With respect to the extent’s tblspace, the extent starts on logical page 32 (0x20).</p>
<p><code>此条目描述了一个 extent，其首页位于 1 号 dbspace 的第 1637 (0x665) 页。对于该 extent 的 tblspace，该范围从逻辑页 32 (0x20) 开始。</code></p>
<p>Every extent slot ends with an <em>on-deck</em> or <em>cap</em> extent entry, one poised to accept the dbspace offset of the next allocated extent. Serving as a kind of cap on the array, the last extent entry contains the logical page number for the next extent to be allocated, and a null value to act as placeholder for the dbspace offset for that extent.</p>
<p><code>每个 extent slot 最后都有一个 on-deck 或 cap  extent条目，准备接受下一个分配 extent 的 dbspace 偏移量。作为数组的一种上限，最后一个 extent 条目包含下一个要分配的 extent 的逻辑页码，以及一个空值，作为该 extent 的 dbspace 偏移量的占位符。</code></p>
<blockquote>
<p>poised 英[pɔɪzd] 美[pɔɪzd]<br>adj. 摆好姿势准备行动的</p>
</blockquote>
<p><strong>Slot 6: Page Versioning</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505171849672.png" alt="image-20250517184920542"></p>
<p><strong>Notes:</strong></p>
<p>If a table is altered and the database server is able to alter the table in-place, then an additional slot is required to handle the versioning of extents in the tblspace.</p>
<p><code>如果更改了表，且 server 能够就地更改表，则需要一个额外的 slot 来处理 tblspace 中 extent 的版本管理。</code></p>
<p>An <em>in-place alter</em> occurs when an ALTER TABLE command is executed and the changes to the table structure do not require a table rebuild. Instead, the database server simply records the change on an additional page in the tblspace tblspace. This page is an extension of the partition page and the only slot on this page is identified as <em>slot 6</em>. The logical page number of the new page is placed in the <strong>pg_next</strong> field in the header of the original <em>partition</em> page.</p>
<p><code>当执行 ALTER TABLE 命令，表结构的更改不需要重建表时，就会发生就地更改。此时，server 只需在 tblspace tblspace 中的一个附加页面上记录更改。该页面是 partition page 的扩展，页面上唯一的 slot 被标识为 slot 6。新页面的逻辑页码放在原始 partition 页头的 pg_next 字段中。</code></p>
<p>chatgpt 和 gemini 都将 Instead 翻译成”此时“，DeelL翻译成”相反“感觉确实不合适</p>
<p>If a row in the altered table is updated and there is room on the page for all rows to be converted to the new version, then all rows are updated and the new version is recorded on the page. If there is not enough room for all rows on the page to be reversioned, then the updated row is altered and moved to a page that only contains rows of the same version. The version number is recorded in the <strong>pg_next</strong> field in the header of each <em>data</em> page.</p>
<p><code>如果修改后的表中的某一行被更新，并且页面上有足够的空间将所有行转换为新版本，那么所有行都会被更新，并且新版本信息会被记录在该页面上。如果页面空间不足，无法对所有行进行版本转换，则更新的那一行会被修改并移动到一个仅包含相同版本行的页面中。版本号会被记录在每个数据页（data page）页头的 pg_next 字段中。</code></p>
<blockquote>
<p>chagpt</p>
<h3 id="一、表结构更改会引入“版本”概念"><a href="#一、表结构更改会引入“版本”概念" class="headerlink" title="一、表结构更改会引入“版本”概念"></a>一、表结构更改会引入“版本”概念</h3><p>当你使用 <code>ALTER TABLE</code>（比如增加列、修改字段类型）修改表结构时，如果数据库支持 <strong>in-place alter</strong>，它不会立即重建整张表，而是通过“版本管理”来处理这种变化。</p>
<p>也就是说：</p>
<ul>
<li>表的旧结构是“版本1”；</li>
<li>修改后生成一个“版本2”的结构；</li>
<li>原先的旧行仍然保持版本1的格式，直到被访问或更新。</li>
</ul>
<hr>
<h3 id="二、为什么更新一行可能会影响整页？"><a href="#二、为什么更新一行可能会影响整页？" class="headerlink" title="二、为什么更新一行可能会影响整页？"></a>二、为什么更新一行可能会影响整页？</h3><p>Informix 之类的数据库系统出于 <strong>存储和性能优化考虑</strong>，往往会这样设计：</p>
<blockquote>
<p><strong>同一个数据页（data page）中尽量只存储相同结构版本的记录。</strong></p>
</blockquote>
<p>这就意味着：</p>
<ol>
<li>如果一页中原本存储的全是版本1的行；</li>
<li>你更新了其中的一行（让它变成了版本2）；</li>
<li>数据库会检查这一页是否有足够空间，把<strong>这整页中的所有行都转换成版本2</strong>；</li>
<li>如果空间够，就一并转换并更新页面元数据；</li>
<li>如果空间不够，只更新这一行，并把它迁移到一个专门存放版本2记录的新页中。</li>
</ol>
<hr>
<h3 id="三、这样做的目的是什么？"><a href="#三、这样做的目的是什么？" class="headerlink" title="三、这样做的目的是什么？"></a>三、这样做的目的是什么？</h3><p>主要是为了：</p>
<ul>
<li><strong>简化行的读取逻辑</strong>：读取时不需要一行一行地判断是哪个版本；</li>
<li><strong>提高性能</strong>：相同版本的行可以共享解析逻辑，减少额外开销；</li>
<li><strong>支持表结构的动态演进</strong>，避免一次性重写整表带来的高成本。</li>
</ul>
</blockquote>
<p>Since a table can be altered several times, the database server uses <em>versioning</em> to keep track of which version of the table is used to describe the pages in an extent that contain updated rows.</p>
<p><code>由于一张表可能会被多次修改，server 使用版本控制（versioning）来跟踪用于描述包含已更新行的 extent 中各页面所对应的表结构版本。</code></p>
<p>Slot 6 contains the following information:</p>
<p> <strong>•</strong> Version number</p>
<p> <strong>•</strong> Number of columns added in this version</p>
<p> <strong>•</strong> Number of pages that contain rows that have not been modified</p>
<p> <strong>•</strong> Logical page number in the tblspace tblspace where descriptor information is stored</p>
<p> <strong>•</strong> Uncompressed size of a row before the table was altered</p>
<p> <strong>•</strong> Uncompressed size of a row after the table was altered</p>
<p><strong>The Physical Log</strong></p>
<p>Some important facts:</p>
<p>– The physical log is used during fast recovery.</p>
<p><code>物理日志用于快速恢复。</code></p>
<p>– In most customer systems, the physical log is set too small causing checkpoints too occur too frequently.</p>
<p><code>在大多数客户的系统中，物理日志设置得过小，导致检查点出现得过于频繁。</code></p>
<p>– It can be moved outside the root dbspace, and usually should be.</p>
<p><code>它可以移到 root dbspace 之外，通常也应该这样做。</code></p>
<p><strong>Notes:</strong></p>
<p>While the physical log might not be of much use in a system that runs perfectly every day of the year, it is crucial to Informix Dynamic Server’s fast recovery mechanism as well as its archiving algorithm, both of which can come in quite handy in the world of power failures and disk crashes that most of us inhabit.</p>
<p><code>虽然物理日志在全年每天都完美运行的系统中可能用处不大，但它对 IDS 的快速恢复机制及其归档算法却至关重要，而在我们大多数人所处的这个充满断电和磁盘崩溃的现实世界中，这两者往往非常有用。</code></p>
<blockquote>
<p>inhabit 英[ɪnˈhæbɪt] 美[ɪnˈhæbɪt]<br>vt.居住在;栖居于;</p>
</blockquote>
<p>The initial size of the physical log is usually much too small, which can cause checkpoints to occur much too frequently. Sizing the physical log too small is a common mistake of novice administrators.</p>
<p><code>物理日志的初始大小通常太小，这可能会导致检查点出现得过于频繁。将物理日志设置得过小是新手管理员常犯的错误。</code></p>
<p><strong>Physical Log Page Structure</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505172010750.png" alt="image-20250517201048659"></p>
<p><strong>Notes:</strong></p>
<p>The slide above shows the structure of a physical log page. Pages in the physical log are identical to their pages of origin. The only way to tell that a page came from the physical log is by looking at the page address (offset and chunk). The page contains the address of the original page location and not the physical location within the physical log.</p>
<p><code>上面的幻灯片展示了一个物理日志页的结构。物理日志中的页面与它们原始来源的页面是完全相同的。判断一个页面是否来自物理日志的唯一方法是查看其页地址（偏移量和chunk号）。该页面记录的是原始页面的位置地址，而不是其在物理日志中的实际物理位置。</code></p>
<blockquote>
<p>identical 完全相同的 英[aɪˈdentɪkl] 美[aɪˈdentɪkl]</p>
</blockquote>
<p><strong>Logical Log File Structure</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505172017022.png" alt="image-20250517201756936"></p>
<p><strong>Notes:</strong></p>
<p>Each logical log is a string of contiguous log pages. Each page within an individual log is numbered, beginning with 0. The location of that number on the page is shown in the next slide.</p>
<p><code>每个逻辑日志由一串连续的日志页组成。每个日志中的页面都从编号 0 开始。该编号在页面中的位置将在下一张幻灯片中展示。</code></p>
<p>上图就是一个逻辑日志，有一连串的逻辑日志页面，从编号0开始</p>
<p>Keep in mind that a <em>log file</em> is an extent within a chunk that does not go anywhere and is constantly overwritten. A log file serves as the temporary home of a <em>logical log</em>, which is unique. It is the logical log, not the log file, that is backed up to tape.</p>
<p><code>请记住，日志文件（log file）是位于某个 chunk 中的一个 extent，它不会被移动，并且会被不断覆盖。日志文件是某个逻辑日志（logical log）的临时存储位置，而每个逻辑日志都是唯一的。被备份到磁带上的，是逻辑日志，而不是日志文件。</code></p>
<p>A logical log can contain any number of pages from one to the total number available in a log file.</p>
<p><code>一个逻辑日志可以包含任意数量的页面，从1页到日志文件中可用的总页数。</code></p>
<p>Logical log pages are manufactured one after another in the logical log buffer, and written out in series each time the buffer is flushed.</p>
<p><code>逻辑日志页在逻辑日志缓冲区中逐个生成，并在每次刷新缓冲区时按顺序写出。</code></p>
<blockquote>
<p>manufacture<br>英[ˌmænjuˈfæktʃə(r)] 美[ˌmænjuˈfæktʃər]<br>vt.制造;产生(一种物质);生成;(用机器)大量生产;捏造;编造;成批制造;<br>n.批量生产;工业品;大量制造;</p>
</blockquote>
<p><strong>Logical Log Page Structure</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505172036583.png" alt="image-20250517203607494"></p>
<p><strong>Notes:</strong></p>
<p>The structure of a logical log page, as pictured above, might suggest the sequential method by which log records are generally accessed. Note for example that the page has no slot table. (The length of each record is stored within the record itself.) Note also that logical log data is very fluid, spilling from one page onto the next without fanfare (though a record must be fully contained within a log file). Even the page header has a few surprises.</p>
<p><code>如上图所示，逻辑日志页的结构可能暗示了日志记录通常是以顺序方式访问的。比如，请注意该页面没有 slot table，因为每条记录的长度是保存在记录本身中的。还要注意，逻辑日志数据非常灵活，可以自然地从一个页面延伸到下一个页面（不过一条记录必须完整地存储在同一个日志文件中）。甚至页头也有一些惊喜。</code></p>
<blockquote>
<p>fluid英[ˈfluːɪd] 美[ˈfluːɪd]<br>n.液体;流体;液;<br>adj.流体的;流动的;不稳定的;易变的;流畅优美的;</p>
<p>spilling 英[ˈspɪlɪŋ] 美[ˈspɪlɪŋ]<br>v.(使)洒出，泼出，溢出;涌出;蜂拥而出;<br>n.木片，纸捻；洒出量；摔下，跌落;（Spilling）（挪、英、美）施皮林（人名）;</p>
<p>fanfare 英[ˈfænfeə(r)] 美[ˈfænfer]<br>n.大张旗鼓;号角花彩，号角齐鸣(欢迎仪式等上奏的响亮短曲);(为庆祝而在媒体上的)喧耀;</p>
</blockquote>
<p><strong>pg_nslots</strong></p>
<p>This is unused, since there is no real concept of slots on a log page.</p>
<p><code>这是未使用的，因为日志页面上没有真正的slot概念。</code></p>
<p><strong>pg_frcnt</strong></p>
<p>This is always zero, even for pages that are not full (note that <strong>pg_frptr</strong> is accurate). The reason has more to do with coincidence than design.</p>
<p><code>即使页面未满，该值也始终为0（请注意，pg_frptr 是准确的）。其原因更多是巧合，而非设计。</code></p>
<p>下面解释为什么是0</p>
<blockquote>
<p>coincidence 巧合 英[kəʊˈɪnsɪdəns] 美[koʊˈɪnsɪdəns]</p>
</blockquote>
<p>Log pages within the log buffer are allowed to fill to the last byte, usually continuing the last record on the next page. So a large number of log pages are truly full, especially when buffered logging is used exclusively.</p>
<p><code>日志缓冲区内的日志页可以填满到其最后一个字节，通常会将最后一条记录延续到下一页。因此，大量的日志页会真正地被完全填满，尤其是在只使用（或：专门采用）缓冲日志记录（buffered logging）的情况下。</code></p>
<p>However, an early buffer flush, forced by a checkpoint or a commit record for a database with unbuffered logging, for example, tend to come at a time when the last page in the buffer is only partly full. Once flushed to the log file, a log page cannot be changed; additional records cannot be added to it. The reason even these pages have a <strong>pg_frcnt</strong> of 0 is this: just before the log buffer is flushed, the flushing process sets the value of <strong>pg_frcnt</strong> on the last page in the buffer to 0, making the page look artificially full in order to prevent another engine process from writing to the page while the I&#x2F;O is being performed.</p>
<p><code>然而，例如由检查点 或 采用非缓冲日志记录的数据库的提交记录 所触发的提前缓冲区刷新，往往发生在缓冲区最后一页仅部分填充之时。日志页一旦刷新到日志文件便无法更改，也不能再向其添加额外记录。即便这些页面仅部分填充，其 pg_frcnt 值也为0，原因如下：在日志缓冲区刷新前夕，刷新进程会将缓冲区最后一页的 pg_frcnt 值设为0，从而人为地将该页标记为“已满”，以防止在I/O操作执行期间，其他引擎进程尝试写入该页。</code></p>
<p><strong>pg_next</strong></p>
<p>On a logical log page, this element of the page header contains the unique ID of the logical log.</p>
<p><code>在逻辑日志页面上，页头的这一元素包含逻辑日志的唯一 ID。</code></p>
<p><strong>pg_prev</strong></p>
<p>On a logical log page, this element of the page header contains the page offset (similar to a logical page number) of the log page. Note that this is the offset within the log, and as always, page offsets begin with 0.</p>
<p><code>在逻辑日志页中，页头的这一元素包含日志页的页面偏移量（类似于逻辑页码）。请注意，这是在日志中的偏移量，而页面偏移量总是以 0 开始。</code></p>
<p><strong>Logical Log Position (Logpos)</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/frh16/imghost/img/202505172120865.png" alt="image-20250517212040764"></p>
<p><strong>Notes:</strong></p>
<p>Log records are uniquely addressed only within a particular logical log. The address used is called a <em>logical log position</em>, or <em>logpos</em> for short. It is a 4-byte integer code that describes the position of a log record in terms of a page offset and a byte offset. The page offset is with respect to the beginning of the log, and is indexed from 0. The byte offset is with respect to the beginning of the page, and is also indexed from 0, though because of the space taken by the page header, this value should never be less than 0x018.</p>
<p><code>日志记录只能在特定逻辑日志中唯一寻址。使用的地址称为 logical log position，简称 logpos。它是一个 4 字节整数代码，用页面偏移和字节偏移来描述日志记录的位置。页面偏移量相对于日志的起始位置，索引从 0 开始。 字节偏移量相对于页面的起始位置，索引也从 0 开始，但由于页面头占用了空间，该值不应小于 0x018。</code></p>
<p><strong>Hint</strong></p>
<p>Assume you are told a logical log record is located in a logical log with a unique ID of 234 and a logpos of 0x12018. How would you find it? Using the more current of your two checkpoint&#x2F;logical log reserved pages in the root chunk, you could find the physical address of log number 234. Once at that page, you would offset 0x12 pages into the log to find the correct log page, then 0x018 bytes into that page to find the log record.</p>
<p><code>假设有一条逻辑日志记录位于逻辑日志中，其唯一 ID 为 234，logpos 为 0x12018。你将如何找到它？使用 root chunk 中两个 checkpoint/logical log 保留页面中的最新页面，可以找到日志编号 234 的物理地址。找到该页面后，在日志中偏移 0x12 页，找到正确的日志页，然后在该页中偏移 0x018 字节，找到日志记录。</code></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://frh16.github.io/2025/05/09/IX9111/3/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2025/05/05/IX9111/2/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">IX9111 - Unit 2. The Dynamic Server Page</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2025
        <i class="ri-heart-fill heart_icon"></i> fengrh
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>